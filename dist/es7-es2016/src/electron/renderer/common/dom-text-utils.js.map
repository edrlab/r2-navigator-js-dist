{"version":3,"file":"dom-text-utils.js","sourceRoot":"","sources":["../../../../../../src/electron/renderer/common/dom-text-utils.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport { split } from \"sentence-splitter\";\n\nimport { uniqueCssSelector } from \"../common/cssselector2\";\n\nexport function combineTextNodes(textNodes: Node[], skipNormalize?: boolean): string {\n    if (textNodes && textNodes.length) {\n        let str = \"\";\n        for (const textNode of textNodes) {\n            if (textNode.nodeValue) { // excludes purely-whitespace text nodes\n                // normalizeText() preserves prefix/suffix whitespace (collapsed to single)\n                // if (str.length) {\n                //     str += \" \";\n                // }\n                str += (skipNormalize ? textNode.nodeValue : normalizeText(textNode.nodeValue));\n            }\n        }\n        return str;\n    }\n    return \"\";\n}\n\nexport function getLanguage(el: Element): string | undefined {\n\n    let currentElement = el;\n\n    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {\n\n        let lang = currentElement.getAttribute(\"xml:lang\");\n        if (!lang) {\n            lang = currentElement.getAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"lang\");\n        }\n        if (!lang) {\n            lang = currentElement.getAttribute(\"lang\");\n        }\n        if (lang) {\n            return lang;\n        }\n\n        currentElement = currentElement.parentNode as Element;\n    }\n\n    return undefined;\n}\n\nexport function getDirection(el: Element): string | undefined {\n\n    let currentElement = el;\n\n    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {\n\n        const dir = currentElement.getAttribute(\"dir\");\n        if (dir) {\n            return dir;\n        }\n\n        currentElement = currentElement.parentNode as Element;\n    }\n\n    return undefined;\n}\n\nexport function normalizeHtmlText(str: string): string {\n    return str.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\n\nexport function normalizeText(str: string): string {\n    // tslint:disable-next-line:max-line-length\n    return normalizeHtmlText(str).replace(/\\n/g, \" \").replace(/\\s\\s+/g, \" \"); // no trim(), we collapse multiple whitespaces into single, preserving prefix and suffix (if any)\n}\n\nexport interface ITtsQueueItem {\n    dir: string | undefined;\n    lang: string | undefined;\n    parentElement: Element;\n    textNodes: Node[];\n    combinedText: string; // combineText(this.textNodes)\n    combinedTextSentences: string[] | undefined;\n    combinedTextSentencesRangeBegin: number[] | undefined;\n    combinedTextSentencesRangeEnd: number[] | undefined;\n}\n\nexport interface ITtsQueueItemReference {\n    item: ITtsQueueItem;\n    iArray: number; // ITtsQueueItem[]\n    iSentence: number; // ITtsQueueItem.combinedTextSentences\n    iGlobal: number; // ITtsQueueItem[] and ITtsQueueItem.combinedTextSentences\n}\n\nexport function consoleLogTtsQueueItem(i: ITtsQueueItem) {\n    console.log(\"<<----\");\n    console.log(i.dir);\n    console.log(i.lang);\n    const cssSelector = uniqueCssSelector(i.parentElement, i.parentElement.ownerDocument as Document);\n    console.log(cssSelector);\n    console.log(i.parentElement.tagName);\n    console.log(i.combinedText);\n    if (i.combinedTextSentences) {\n        console.log(\".......\");\n        for (const j of i.combinedTextSentences) {\n            console.log(j);\n        }\n        console.log(\".......\");\n    }\n    console.log(\"---->>\");\n}\nexport function consoleLogTtsQueue(f: ITtsQueueItem[]) {\n    for (const i of f) {\n        consoleLogTtsQueueItem(i);\n    }\n}\n\nexport function getTtsQueueLength(items: ITtsQueueItem[]) {\n    let l = 0;\n    for (const it of items) {\n        if (it.combinedTextSentences) {\n            l += it.combinedTextSentences.length;\n        } else {\n            l++;\n        }\n    }\n    return l;\n}\n\nexport function getTtsQueueItemRefText(obj: ITtsQueueItemReference): string {\n    if (obj.iSentence === -1) {\n        return obj.item.combinedText;\n    }\n    if (obj.item.combinedTextSentences) {\n        return obj.item.combinedTextSentences[obj.iSentence];\n    }\n    return \"\";\n}\n\nexport function getTtsQueueItemRef(items: ITtsQueueItem[], index: number): ITtsQueueItemReference | undefined {\n    let i = -1;\n    let k = -1;\n    for (const it of items) {\n        k++;\n        if (it.combinedTextSentences) {\n            let j = -1;\n            for (const _sent of it.combinedTextSentences) {\n                j++;\n                i++;\n                if (index === i) {\n                    return { item: it, iArray: k, iGlobal: i, iSentence: j };\n                }\n            }\n        } else {\n            i++;\n            if (index === i) {\n                return { item: it, iArray: k, iGlobal: i, iSentence: -1 };\n            }\n        }\n    }\n    return undefined;\n}\n\nexport function findTtsQueueItemIndex(\n    ttsQueue: ITtsQueueItem[],\n    element: Element,\n    startTextNode: Node | undefined,\n    startTextNodeOffset: number,\n    rootElem: Element): number {\n    let i = 0;\n    for (const ttsQueueItem of ttsQueue) {\n        if (startTextNode && ttsQueueItem.textNodes) {\n            if (ttsQueueItem.textNodes.includes(startTextNode)) {\n                if (ttsQueueItem.combinedTextSentences &&\n                    ttsQueueItem.combinedTextSentencesRangeBegin &&\n                    ttsQueueItem.combinedTextSentencesRangeEnd) {\n                    let offset = 0;\n                    for (const txtNode of ttsQueueItem.textNodes) {\n                        if (!txtNode.nodeValue && txtNode.nodeValue !== \"\") {\n                            continue;\n                        }\n                        if (txtNode === startTextNode) {\n                            offset += startTextNodeOffset;\n                            break;\n                        }\n                        offset += txtNode.nodeValue.length;\n                    }\n                    let j = i - 1;\n                    // let iSent = -1;\n                    for (const end of ttsQueueItem.combinedTextSentencesRangeEnd) {\n                        // iSent++;\n                        j++;\n                        if (end < offset) {\n                            continue;\n                        }\n                        return j;\n                    }\n                    return i;\n                } else { // ttsQueueItem.combinedText\n                    return i;\n                }\n            }\n        } else if (element === ttsQueueItem.parentElement ||\n            (ttsQueueItem.parentElement !== (element.ownerDocument as Document).body &&\n                ttsQueueItem.parentElement !== rootElem &&\n                ttsQueueItem.parentElement.contains(element)) ||\n            element.contains(ttsQueueItem.parentElement)) {\n            return i;\n        }\n        if (ttsQueueItem.combinedTextSentences) {\n            i += ttsQueueItem.combinedTextSentences.length;\n        } else { // ttsQueueItem.combinedText\n            i++;\n        }\n    }\n    return -1;\n}\n\nexport function generateTtsQueue(rootElement: Element, splitSentences: boolean): ITtsQueueItem[] {\n\n    const ttsQueue: ITtsQueueItem[] = [];\n    const elementStack: Element[] = [];\n\n    function processTextNode(textNode: Node) {\n\n        if (textNode.nodeType !== Node.TEXT_NODE) {\n            return;\n        }\n        // test for word regexp?  || !/\\w/.test(textNode.nodeValue)\n        if (!textNode.nodeValue || !textNode.nodeValue.trim().length) {\n            return;\n        }\n        const parentElement = elementStack[elementStack.length - 1];\n        if (!parentElement) {\n            return;\n        }\n\n        const lang = textNode.parentElement ? getLanguage(textNode.parentElement) : undefined;\n        const dir = textNode.parentElement ? getDirection(textNode.parentElement) : undefined;\n\n        let current = ttsQueue[ttsQueue.length - 1];\n        if (!current || current.parentElement !== parentElement || current.lang !== lang || current.dir !== dir) {\n            current = {\n                combinedText: \"\", // filled in later (see trySplitTexts())\n                combinedTextSentences: undefined, // filled in later, if text is further chunkable\n                combinedTextSentencesRangeBegin: undefined,\n                combinedTextSentencesRangeEnd: undefined,\n                dir,\n                lang,\n                parentElement,\n                textNodes: [],\n            };\n            ttsQueue.push(current);\n        }\n        current.textNodes.push(textNode);\n    }\n\n    let first = true;\n    function processElement(element: Element) {\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n            return;\n        }\n\n        // tslint:disable-next-line:max-line-length\n        const isIncluded = first || element.matches(\"h1, h2, h3, h4, h5, h6, p, th, td, caption, li, blockquote, q, dt, dd, figcaption, div, pre\");\n        first = false;\n        if (isIncluded) {\n            elementStack.push(element);\n        }\n\n        for (const childNode of element.childNodes) {\n            switch (childNode.nodeType) {\n                case Node.ELEMENT_NODE:\n                    const childElement = childNode as Element;\n                    // tslint:disable-next-line:max-line-length\n                    const isExcluded = childElement.matches(\"img, sup, sub, audio, video, source, button, canvas, del, dialog, embed, form, head, iframe, meter, noscript, object, s, script, select, style, textarea\");\n                    // code, nav, dl, figure, table, ul, ol\n                    if (!isExcluded) {\n                        processElement(childElement);\n                    } else if (childElement.tagName\n                        && childElement.tagName.toLowerCase() === \"img\" &&\n                        (childElement as HTMLImageElement).src) {\n                        const altAttr = childElement.getAttribute(\"alt\");\n                        if (altAttr) {\n                            const txt = altAttr.trim();\n                            if (txt) {\n                                const lang = getLanguage(childElement);\n                                const dir = undefined;\n                                ttsQueue.push({\n                                    combinedText: txt,\n                                    combinedTextSentences: undefined,\n                                    combinedTextSentencesRangeBegin: undefined,\n                                    combinedTextSentencesRangeEnd: undefined,\n                                    dir,\n                                    lang,\n                                    parentElement: childElement,\n                                    textNodes: [],\n                                });\n                            }\n                        }\n                    }\n                    break;\n                case Node.TEXT_NODE:\n                    if (elementStack.length !== 0) {\n                        processTextNode(childNode);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (isIncluded) {\n            elementStack.pop();\n        }\n    }\n\n    processElement(rootElement);\n\n    function finalizeTextNodes(ttsQueueItem: ITtsQueueItem) {\n        if (!ttsQueueItem.textNodes || !ttsQueueItem.textNodes.length) {\n            // img@alt can set combinedText (no text nodes)\n            if (!ttsQueueItem.combinedText || !ttsQueueItem.combinedText.length) {\n                ttsQueueItem.combinedText = \"\";\n            }\n            ttsQueueItem.combinedTextSentences = undefined;\n            return;\n        }\n\n        ttsQueueItem.combinedText = combineTextNodes(ttsQueueItem.textNodes, true).replace(/[\\r\\n]/g, \" \");\n        // ttsQueueItem.combinedText = ttsQueueItem.combinedTextSentences ?\n        //     combineTextNodes(ttsQueueItem.textNodes, false).trim() :\n        //     combineTextNodes(ttsQueueItem.textNodes, true);\n        let skipSplitSentences = false;\n        let parent: Element | null = ttsQueueItem.parentElement;\n        while (parent) {\n            if (parent.tagName) {\n                const tag = parent.tagName.toLowerCase();\n                if (tag === \"pre\" || tag === \"code\" ||\n                    tag === \"video\" || tag === \"audio\") {\n                    skipSplitSentences = true;\n                    break;\n                }\n            }\n            parent = parent.parentElement;\n        }\n        if (splitSentences && !skipSplitSentences) {\n            try {\n                const txt = ttsQueueItem.combinedText; // no further transforms?\n                ttsQueueItem.combinedTextSentences = undefined;\n                const sentences = split(txt);\n                ttsQueueItem.combinedTextSentences = [];\n                ttsQueueItem.combinedTextSentencesRangeBegin = [];\n                ttsQueueItem.combinedTextSentencesRangeEnd = [];\n                for (const sentence of sentences) {\n                    if (sentence.type === \"Sentence\") {\n                        // console.log(sentence.raw, JSON.stringify(sentence.range, null, 2));\n\n                        ttsQueueItem.combinedTextSentences.push(sentence.raw);\n                        ttsQueueItem.combinedTextSentencesRangeBegin.push(sentence.range[0]);\n                        ttsQueueItem.combinedTextSentencesRangeEnd.push(sentence.range[1]);\n                    }\n                    // else {\n                    //     console.log(sentence.type);\n                    // }\n                }\n                if (ttsQueueItem.combinedTextSentences.length === 0 ||\n                    ttsQueueItem.combinedTextSentences.length === 1) {\n                    ttsQueueItem.combinedTextSentences = undefined;\n                } else {\n                    // let total = 0;\n                    // ttsQueueItem.combinedTextSentences.forEach((sent) => {\n                    //     total += sent.length;\n                    // });\n                    // const expectedWhiteSpacesSeparators = ttsQueueItem.combinedTextSentences.length - 1;\n                    // if (total !== ttsQueueItem.combinedText.length &&\n                    //     ((ttsQueueItem.combinedText.length - total) !== expectedWhiteSpacesSeparators)) {\n                    //     console.log(\"sentences total !== item.combinedText.length\");\n                    //     console.log(total + \" !== \" + ttsQueueItem.combinedText.length);\n                    //     consoleLogTtsQueueItem(ttsQueueItem);\n                    //     console.log(JSON.stringify(sentences, null, 4));\n                    // }\n                }\n            } catch (err) {\n                console.log(err);\n                ttsQueueItem.combinedTextSentences = undefined;\n            }\n        } else {\n            ttsQueueItem.combinedTextSentences = undefined;\n        }\n    }\n\n    for (const ttsQueueItem of ttsQueue) {\n        finalizeTextNodes(ttsQueueItem);\n    }\n\n    return ttsQueue;\n}\n"]}