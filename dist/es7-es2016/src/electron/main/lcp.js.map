{"version":3,"file":"lcp.js","sourceRoot":"","sources":["../../../../../src/electron/main/lcp.ts"],"names":[],"mappings":";;;;AAOA,iCAAiC;AACjC,gCAAgC;AAIhC,MAAM,KAAK,GAAG,MAAM,CAAC,gCAAgC,CAAC,CAAC;AAEvD,SAAsB,YAAY,CAC9B,kBAA0B,EAC1B,mBAA2B,EAC3B,SAAmB,EACnB,WAAoB;;QAEpB,MAAM,WAAW,GAAG,kBAAkB,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC;QAC9E,IAAI,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE;YAClC,OAAO,OAAO,CAAC,MAAM,CAAC,4BAA4B,GAAG,mBAAmB,CAAC,CAAC;SAC7E;QAED,IAAI,eAAyB,CAAC;QAC9B,IAAI,WAAW,EAAE;YACb,eAAe,GAAG,SAAS,CAAC;SAC/B;aAAM;YACH,eAAe,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;gBACxC,MAAM,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;gBAC7C,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;gBACzB,MAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBAC7C,OAAO,aAAa,CAAC;YAGzB,CAAC,CAAC,CAAC;SACN;QAED,IAAI;YACA,OAAO,MAAM,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC;SAC7D;QAAC,OAAO,GAAG,EAAE;YACV,KAAK,CAAC,GAAG,CAAC,CAAC;YACX,KAAK,CAAC,sCAAsC,GAAG,GAAG,CAAC,CAAC;YACpD,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SA6B9B;IACL,CAAC;CAAA;AA5DD,oCA4DC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as crypto from \"crypto\";\nimport * as debug_ from \"debug\";\n\nimport { Server } from \"@r2-streamer-js/http/server\";\n\nconst debug = debug_(\"r2:navigator#electron/main/lcp\");\n\nexport async function doTryLcpPass(\n    publicationsServer: Server,\n    publicationFilePath: string,\n    lcpPasses: string[],\n    isSha256Hex: boolean) {\n\n    const publication = publicationsServer.cachedPublication(publicationFilePath);\n    if (!publication || !publication.LCP) {\n        return Promise.reject(\"no publication LCP data?! \" + publicationFilePath);\n    }\n\n    let passesSha256Hex: string[];\n    if (isSha256Hex) {\n        passesSha256Hex = lcpPasses;\n    } else {\n        passesSha256Hex = lcpPasses.map((lcpPass) => {\n            const checkSum = crypto.createHash(\"sha256\");\n            checkSum.update(lcpPass);\n            const passSha256Hex = checkSum.digest(\"hex\");\n            return passSha256Hex;\n            // const lcpPass64 = Buffer.from(hash).toString(\"base64\");\n            // const lcpPassHex = Buffer.from(lcpPass64, \"base64\").toString(\"utf8\");\n        });\n    }\n\n    try {\n        return await publication.LCP.tryUserKeys(passesSha256Hex);\n    } catch (err) {\n        debug(err);\n        debug(\"FAIL publication.LCP.tryUserKeys(): \" + err);\n        return Promise.reject(err);\n        // DRMErrorCode (from r2-lcp-client)\n        // 1 === NO CORRECT PASSPHRASE / UERKEY IN GIVEN ARRAY\n        //     // No error\n        //     NONE = 0,\n        //     /**\n        //         WARNING ERRORS > 10\n        //     **/\n        //     // License is out of date (check start and end date)\n        //     LICENSE_OUT_OF_DATE = 11,\n        //     /**\n        //         CRITICAL ERRORS > 100\n        //     **/\n        //     // Certificate has been revoked in the CRL\n        //     CERTIFICATE_REVOKED = 101,\n        //     // Certificate has not been signed by CA\n        //     CERTIFICATE_SIGNATURE_INVALID = 102,\n        //     // License has been issued by an expired certificate\n        //     LICENSE_SIGNATURE_DATE_INVALID = 111,\n        //     // License signature does not match\n        //     LICENSE_SIGNATURE_INVALID = 112,\n        //     // The drm context is invalid\n        //     CONTEXT_INVALID = 121,\n        //     // Unable to decrypt encrypted content key from user key\n        //     CONTENT_KEY_DECRYPT_ERROR = 131,\n        //     // User key check invalid\n        //     USER_KEY_CHECK_INVALID = 141,\n        //     // Unable to decrypt encrypted content from content key\n        //     CONTENT_DECRYPT_ERROR = 151\n    }\n}\n"]}