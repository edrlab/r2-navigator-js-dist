{"version":3,"file":"selection.js","sourceRoot":"","sources":["../../../../../src/electron/common/selection.ts"],"names":[],"mappings":";;;AA2CA,SAAgB,UAAU,CAAC,EAAc,EAAE,EAAc;IACrD,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,EAAE;QACZ,OAAO,KAAK,CAAC;KAChB;IAED,IAAI,EAAE,CAAC,gCAAgC,KAAK,EAAE,CAAC,gCAAgC,EAAE;QAC7E,OAAO,KAAK,CAAC;KAChB;IACD,IAAI,EAAE,CAAC,gCAAgC,KAAK,EAAE,CAAC,gCAAgC,EAAE;QAC7E,OAAO,KAAK,CAAC;KAChB;IACD,IAAI,EAAE,CAAC,WAAW,KAAK,EAAE,CAAC,WAAW,EAAE;QACnC,OAAO,KAAK,CAAC;KAChB;IAED,IAAI,EAAE,CAAC,8BAA8B,KAAK,EAAE,CAAC,8BAA8B,EAAE;QACzE,OAAO,KAAK,CAAC;KAChB;IACD,IAAI,EAAE,CAAC,8BAA8B,KAAK,EAAE,CAAC,8BAA8B,EAAE;QACzE,OAAO,KAAK,CAAC;KAChB;IACD,IAAI,EAAE,CAAC,SAAS,KAAK,EAAE,CAAC,SAAS,EAAE;QAC/B,OAAO,KAAK,CAAC;KAChB;IAED,OAAO,IAAI,CAAC;AAChB,CAAC;AA1BD,gCA0BC;AAgBD,SAAgB,cAAc,CAAC,IAAoB,EAAE,IAAoB;IACrE,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE;QAChB,OAAO,KAAK,CAAC;KAChB;IACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE;QAC7C,OAAO,KAAK,CAAC;KAChB;IACD,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,CAAC,SAAS,EAAE;QACnC,OAAO,CAAC,GAAG,CAAC,wCAAwC,CAAC,CAAC;QACtD,OAAO,KAAK,CAAC;KAChB;IACD,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,EAAE;QAC/B,OAAO,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC;QACpD,OAAO,KAAK,CAAC;KAChB;IACD,OAAO,IAAI,CAAC;AAChB,CAAC;AAhBD,wCAgBC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Selection\n// https://developer.mozilla.org/en-US/docs/Web/API/Range\n\n// A serializable mapping with DOM Range\n// (simply encodes a CSS Selector for element, and if text node, then encodes its parent element)\nexport interface IRangeInfo {\n    // always references an element,\n    // either Range.startContainer if its nodeType == Node.ELEMENT_NODE\n    // or Range.startContainer.parentElement if Range.startContainer.nodeType == Node.TEXT_NODE\n    startContainerElementCssSelector: string;\n    startContainerElementCFI: string | undefined;\n\n    // if i == -1, Range.startContainer is the above element\n    // if i >=0 and i < element.childNodes.length, Range.startContainer is the above element.childNodes[i]\n    // and element.childNodes[i].nodeType == Node.TEXT_NODE\n    startContainerChildTextNodeIndex: number;\n\n    // if Range.startContainer.nodeType == Node.TEXT_NODE\n    // then if j >=0 and j < Range.startContainer.data.length, Range.startContainer.data[j] is the first char,\n    // or if j >= Range.startContainer.data.length, the Range starts after the text but before the text node ends\n    //\n    // if Range.startContainer.nodeType == Node.ELEMENT_NODE\n    // then if j >=0 and j < Range.startContainer.childNodes.length,\n    // Range.startContainer.childNodes[j] is the first node inclusive of the range,\n    // and if j >= Range.startContainer.childNodes.length, the Range starts after the last node,\n    /// but before the parent contents ends\n    startOffset: number;\n\n    endContainerElementCssSelector: string;\n    endContainerElementCFI: string | undefined;\n    endContainerChildTextNodeIndex: number;\n    endOffset: number;\n\n    cfi: string | undefined;\n}\n\nexport function sameRanges(r1: IRangeInfo, r2: IRangeInfo): boolean {\n    if (!r1 || !r2) {\n        return false;\n    }\n\n    if (r1.startContainerElementCssSelector !== r2.startContainerElementCssSelector) {\n        return false;\n    }\n    if (r1.startContainerChildTextNodeIndex !== r2.startContainerChildTextNodeIndex) {\n        return false;\n    }\n    if (r1.startOffset !== r2.startOffset) {\n        return false;\n    }\n\n    if (r1.endContainerElementCssSelector !== r2.endContainerElementCssSelector) {\n        return false;\n    }\n    if (r1.endContainerChildTextNodeIndex !== r2.endContainerChildTextNodeIndex) {\n        return false;\n    }\n    if (r1.endOffset !== r2.endOffset) {\n        return false;\n    }\n\n    return true;\n}\n\nexport interface ISelectedTextInfo {\n    cleanBefore: string;\n    cleanText: string;\n    cleanAfter: string;\n\n    rawBefore: string;\n    rawText: string;\n    rawAfter: string;\n}\n\nexport interface ISelectionInfo extends ISelectedTextInfo {\n    rangeInfo: IRangeInfo;\n}\n\nexport function sameSelections(sel1: ISelectionInfo, sel2: ISelectionInfo): boolean {\n    if (!sel1 || !sel2) {\n        return false;\n    }\n    if (!sameRanges(sel1.rangeInfo, sel2.rangeInfo)) {\n        return false;\n    }\n    if (sel1.cleanText !== sel2.cleanText) {\n        console.log(\"SAME RANGES BUT DIFFERENT CLEAN TEXT??\");\n        return false;\n    }\n    if (sel1.rawText !== sel2.rawText) {\n        console.log(\"SAME RANGES BUT DIFFERENT RAW TEXT??\");\n        return false;\n    }\n    return true;\n}\n"]}