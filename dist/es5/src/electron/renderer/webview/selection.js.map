{"version":3,"file":"selection.js","sourceRoot":"","sources":["../../../../../../src/electron/renderer/webview/selection.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport { IRangeInfo, ISelectedTextInfo, ISelectionInfo } from \"../../common/selection\";\nimport { IReadiumElectronWebviewWindow } from \"./state\";\n\nconst IS_DEV = (process.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"dev\");\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Selection\n\nfunction dumpDebug(\n    msg: string,\n    startNode: Node, startOffset: number,\n    endNode: Node, endOffset: number,\n    getCssSelector: (element: Element) => string,\n) {\n    console.log(\"$$$$$$$$$$$$$$$$$ \" + msg);\n    console.log(\"**** START\");\n    console.log(\"Node type (1=element, 3=text): \" + startNode.nodeType);\n    if (startNode.nodeType === Node.ELEMENT_NODE) {\n        console.log(\"CSS Selector: \" + getCssSelector(startNode as Element));\n        console.log(\"Element children count: \" + startNode.childNodes.length);\n        if (startOffset >= 0 && startOffset < startNode.childNodes.length) {\n            console.log(\"Child node type (1=element, 3=text): \" + startNode.childNodes[startOffset].nodeType);\n            if (startNode.childNodes[endOffset].nodeType === Node.ELEMENT_NODE) {\n                console.log(\"Child CSS Selector: \" + getCssSelector(startNode.childNodes[endOffset] as Element));\n            }\n        } else {\n            console.log(\"startOffset >= 0 && startOffset < startNode.childNodes.length ... \" +\n                startOffset + \" // \" + startNode.childNodes.length);\n        }\n    }\n    if (startNode.parentNode && startNode.parentNode.nodeType === Node.ELEMENT_NODE) {\n        console.log(\"- Parent CSS Selector: \" + getCssSelector(startNode.parentNode as Element));\n        console.log(\"- Parent element children count: \" + startNode.parentNode.childNodes.length);\n    }\n    console.log(\"Offset: \" + startOffset);\n    console.log(\"**** END\");\n    console.log(\"Node type (1=element, 3=text): \" + endNode.nodeType);\n    if (endNode.nodeType === Node.ELEMENT_NODE) {\n        console.log(\"CSS Selector: \" + getCssSelector(endNode as Element));\n        console.log(\"Element children count: \" + endNode.childNodes.length);\n        if (endOffset >= 0 && endOffset < endNode.childNodes.length) {\n            console.log(\"Child node type (1=element, 3=text): \" + endNode.childNodes[endOffset].nodeType);\n            if (endNode.childNodes[endOffset].nodeType === Node.ELEMENT_NODE) {\n                console.log(\"Child CSS Selector: \" + getCssSelector(endNode.childNodes[endOffset] as Element));\n            }\n        } else {\n            console.log(\"endOffset >= 0 && endOffset < endNode.childNodes.length ... \" +\n                endOffset + \" // \" + endNode.childNodes.length);\n        }\n    }\n    if (endNode.parentNode && endNode.parentNode.nodeType === Node.ELEMENT_NODE) {\n        console.log(\"- Parent CSS Selector: \" + getCssSelector(endNode.parentNode as Element));\n        console.log(\"- Parent element children count: \" + endNode.parentNode.childNodes.length);\n    }\n    console.log(\"Offset: \" + endOffset);\n    console.log(\"$$$$$$$$$$$$$$$$$\");\n}\n\nexport function clearCurrentSelection(win: IReadiumElectronWebviewWindow) {\n    const selection = win.getSelection();\n    if (!selection) {\n        return;\n    }\n    selection.removeAllRanges();\n}\n\nexport const collapseWhitespaces = (str: string) => {\n    return str.replace(/\\n/g, \" \").replace(/\\s\\s+/g, \" \");\n};\n\nexport const cleanupStr = (str: string) => {\n    return collapseWhitespaces(str).trim();\n};\n\nexport function getCurrentSelectionInfo(\n    win: IReadiumElectronWebviewWindow,\n    getCssSelector: (element: Element) => string,\n    computeElementCFI: (node: Node) => string | undefined,\n):\n    ISelectionInfo | undefined {\n\n    const selection = win.getSelection();\n    if (!selection) {\n        return undefined;\n    }\n    if (selection.isCollapsed) {\n        console.log(\"^^^ SELECTION COLLAPSED.\");\n        return undefined;\n    }\n\n    const rawText = selection.toString();\n    const cleanText = collapseWhitespaces(rawText);\n    if (cleanText.length === 0) {\n        console.log(\"^^^ SELECTION TEXT EMPTY.\");\n        return undefined;\n    }\n\n    if (!selection.anchorNode || !selection.focusNode) {\n        return undefined;\n    }\n    const r = selection.rangeCount === 1 ? selection.getRangeAt(0) :\n        createOrderedRange(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n    if (!r || r.collapsed) {\n        console.log(\"$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!\");\n        return undefined;\n    }\n\n    const range = normalizeRange(r);\n    if (IS_DEV) {\n        if (range.startContainer !== r.startContainer) {\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>> SELECTION RANGE NORMALIZE diff: startContainer\");\n            console.log(range.startContainer);\n            console.log(r.startContainer);\n        }\n        if (range.startOffset !== r.startOffset) {\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>> SELECTION RANGE NORMALIZE diff: startOffset\");\n            console.log(`${range.startOffset} !== ${r.startOffset}`);\n        }\n        if (range.endContainer !== r.endContainer) {\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>> SELECTION RANGE NORMALIZE diff: endContainer\");\n            console.log(range.endContainer);\n            console.log(r.endContainer);\n        }\n        if (range.endOffset !== r.endOffset) {\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>> SELECTION RANGE NORMALIZE diff: endOffset\");\n            console.log(`${range.endOffset} !== ${r.endOffset}`);\n        }\n    }\n\n    const tuple = convertRange(range, getCssSelector, computeElementCFI);\n    if (!tuple) {\n        console.log(\"^^^ SELECTION RANGE INFO FAIL?!\");\n        return undefined;\n    }\n    const rangeInfo = tuple[0];\n    const textInfo = tuple[1];\n\n    if (IS_DEV) {\n        if (textInfo.cleanText !== cleanText) {\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>> SELECTION TEXT INFO diff: cleanText\");\n            console.log(`${textInfo.cleanText} !== ${cleanText}`);\n        }\n        if (textInfo.rawText !== rawText) {\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>> SELECTION TEXT INFO diff: rawText\");\n            console.log(`${textInfo.rawText} !== ${rawText}`);\n        }\n    }\n\n    // selection.removeAllRanges();\n    if (IS_DEV && win.READIUM2.DEBUG_VISUALS) {\n        const restoredRange = convertRangeInfo(win.document, rangeInfo);\n        if (restoredRange) {\n            if (restoredRange.startOffset === range.startOffset &&\n                restoredRange.endOffset === range.endOffset &&\n                restoredRange.startContainer === range.startContainer &&\n                restoredRange.endContainer === range.endContainer) {\n                console.log(\"SELECTION RANGE RESTORED OKAY (dev check).\");\n            } else {\n                console.log(\"SELECTION RANGE RESTORE FAIL (dev check).\");\n                // tslint:disable-next-line:max-line-length\n                dumpDebug(\"SELECTION\", selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset, getCssSelector);\n                // tslint:disable-next-line:max-line-length\n                dumpDebug(\"ORDERED RANGE FROM SELECTION\", range.startContainer, range.startOffset, range.endContainer, range.endOffset, getCssSelector);\n                // tslint:disable-next-line:max-line-length\n                dumpDebug(\"RESTORED RANGE\", restoredRange.startContainer, restoredRange.startOffset, restoredRange.endContainer, restoredRange.endOffset, getCssSelector);\n            }\n\n            // setTimeout(() => {\n            //     selection.addRange(restoredRange);\n            // }, 500);\n        } else {\n            console.log(\"CANNOT RESTORE SELECTION RANGE ??!\");\n\n            // setTimeout(() => {\n            //     selection.addRange(range);\n            // }, 500);\n        }\n    } else {\n        // selection.addRange(range);\n    }\n\n    return {\n        rangeInfo,\n\n        cleanBefore: textInfo.cleanBefore,\n        cleanText: textInfo.cleanText,\n        cleanAfter: textInfo.cleanAfter,\n\n        rawBefore: textInfo.rawBefore,\n        rawText: textInfo.rawText,\n        rawAfter: textInfo.rawAfter,\n    };\n}\n\nexport function createOrderedRange(startNode: Node, startOffset: number, endNode: Node, endOffset: number):\n    Range | undefined {\n\n    const range = new Range(); // document.createRange()\n    range.setStart(startNode, startOffset);\n    range.setEnd(endNode, endOffset);\n    if (!range.collapsed) {\n        // console.log(\">>> createOrderedRange RANGE OK\");\n        return range;\n    }\n\n    console.log(\">>> createOrderedRange COLLAPSED ... RANGE REVERSE?\");\n    const rangeReverse = new Range(); // document.createRange()\n    rangeReverse.setStart(endNode, endOffset);\n    rangeReverse.setEnd(startNode, startOffset);\n    if (!rangeReverse.collapsed) {\n        console.log(\">>> createOrderedRange RANGE REVERSE OK.\");\n        return range;\n    }\n\n    console.log(\">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!\");\n    return undefined;\n\n    // let startNode = startNode_;\n    // let startOffset = startOffset_;\n    // if (startNode.nodeType === Node.ELEMENT_NODE) {\n    //     if (startOffset >= 0 && startOffset < startNode.childNodes.length) {\n    //         startNode = startNode.childNodes[startOffset];\n    //     }\n    //     startOffset = -1;\n    // }\n\n    // let endNode = endNode_;\n    // let endOffset = endOffset_;\n    // if (endNode.nodeType === Node.ELEMENT_NODE) {\n    //     if (endOffset >= 0 && endOffset < endNode.childNodes.length) {\n    //         endNode = endNode.childNodes[endOffset];\n    //     }\n    //     endOffset = -1;\n    // }\n\n    // const position = startNode.compareDocumentPosition(endNode);\n\n    // const reverse1 = position === 0 && startOffset > endOffset;\n    // // tslint:disable-next-line:no-bitwise\n    // const reverse2 = position & Node.DOCUMENT_POSITION_PRECEDING;\n    // const reverse = reverse1 || reverse2;\n    // console.log(\"{{{{{{{{{{{ reverse: \" + reverse + \" (\" + reverse1 + \" // \" + reverse2 + \")\");\n\n    // const range = new Range(); // document.createRange()\n    // if (startOffset >= 0 && endOffset >= 0) {\n    //     range.setStart(reverse ? endNode : startNode, reverse ? endOffset : startOffset);\n    //     range.setEnd(reverse ? startNode : endNode, reverse ? startOffset : endOffset);\n    // } else {\n    //     if (reverse) {\n    //         if (endOffset < 0) {\n    //             range.setStartAfter(endNode);\n    //         } else {\n    //             range.setStart(endNode, endOffset);\n    //         }\n    //         if (startOffset < 0) {\n    //             range.setEndBefore(startNode);\n    //         } else {\n    //             range.setEnd(startNode, startOffset);\n    //         }\n    //     } else {\n    //         if (startOffset < 0) {\n    //             range.setStartAfter(startNode);\n    //         } else {\n    //             range.setStart(startNode, startOffset);\n    //         }\n    //         if (endOffset < 0) {\n    //             range.setEndBefore(endNode);\n    //         } else {\n    //             range.setEnd(endNode, endOffset);\n    //         }\n    //     }\n    // }\n\n    // return range;\n}\n\nexport function convertRange(\n    range: Range,\n    getCssSelector: (element: Element) => string,\n    computeElementCFI: (node: Node) => string | undefined,\n):\n    [IRangeInfo, ISelectedTextInfo] | undefined {\n\n    // -----------------\n    const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;\n    const startContainerElement = startIsElement ?\n        range.startContainer as Element :\n        ((range.startContainer.parentNode && range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.startContainer.parentNode as Element : undefined);\n    if (!startContainerElement) {\n        return undefined;\n    }\n    const startContainerChildTextNodeIndex = startIsElement ? -1 :\n        Array.from(startContainerElement.childNodes).indexOf(range.startContainer as ChildNode);\n    if (startContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const startContainerElementCssSelector = getCssSelector(startContainerElement);\n    // -----------------\n    const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;\n    const endContainerElement = endIsElement ?\n        range.endContainer as Element :\n        ((range.endContainer.parentNode && range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.endContainer.parentNode as Element : undefined);\n    if (!endContainerElement) {\n        return undefined;\n    }\n    const endContainerChildTextNodeIndex = endIsElement ? -1 :\n        Array.from(endContainerElement.childNodes).indexOf(range.endContainer as ChildNode);\n    if (endContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const endContainerElementCssSelector = getCssSelector(endContainerElement);\n    // -----------------\n    const commonElementAncestor = getCommonAncestorElement(range.startContainer, range.endContainer);\n    if (!commonElementAncestor) {\n        console.log(\"^^^ NO RANGE COMMON ANCESTOR?!\");\n        return undefined;\n    }\n    if (range.commonAncestorContainer) {\n        const rangeCommonAncestorElement = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ?\n            range.commonAncestorContainer : range.commonAncestorContainer.parentNode;\n        if (rangeCommonAncestorElement && rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE) {\n            if (commonElementAncestor !== rangeCommonAncestorElement) {\n                console.log(\">>>>>> COMMON ANCESTOR CONTAINER DIFF??!\");\n                console.log(getCssSelector(commonElementAncestor));\n                console.log(getCssSelector(rangeCommonAncestorElement as Element));\n            }\n        }\n    }\n    // -----------------\n    const SELECTION_BEFORE_AFTER_TEXT_LENGTH = 30;\n\n    let rawBefore = \"\";\n    const rawText = range.toString();\n    let rawAfter = \"\";\n\n    let cleanBefore = \"\";\n    const cleanText = collapseWhitespaces(rawText);\n    let cleanAfter = \"\";\n\n    let currentParent = commonElementAncestor;\n    while (currentParent) {\n        if (currentParent.tagName?.toLowerCase() === \"html\") {\n            break;\n        }\n\n        const beforeNeedsToGrow = cleanBefore.length < SELECTION_BEFORE_AFTER_TEXT_LENGTH;\n        const afterNeedsToGrow = cleanAfter.length < SELECTION_BEFORE_AFTER_TEXT_LENGTH;\n        if (!beforeNeedsToGrow && !afterNeedsToGrow) {\n            break;\n        }\n\n        if (beforeNeedsToGrow) {\n            try {\n                const rangeBefore = new Range(); // commonElementAncestor.ownerDocument.createRange()\n                rangeBefore.setStartBefore(currentParent);\n                // rangeBefore.setStart(currentParent, 0);\n                // rangeBefore.setEndBefore(range.startContainer);\n                rangeBefore.setEnd(range.startContainer, range.startOffset);\n                rawBefore = rangeBefore.toString();\n                cleanBefore = collapseWhitespaces(rawBefore);\n                if (cleanBefore.length > SELECTION_BEFORE_AFTER_TEXT_LENGTH) {\n                    cleanBefore = cleanBefore.substring(cleanBefore.length - SELECTION_BEFORE_AFTER_TEXT_LENGTH, cleanBefore.length);\n                }\n            } catch (ex1) {\n                console.log(ex1);\n            }\n        }\n\n        if (afterNeedsToGrow) {\n            try {\n                const rangeAfter = new Range(); // commonElementAncestor.ownerDocument.createRange()\n                rangeAfter.setStart(range.endContainer, range.endOffset);\n                rangeAfter.setEndAfter(currentParent);\n                rawAfter = rangeAfter.toString();\n                cleanAfter = collapseWhitespaces(rawAfter);\n                if (cleanAfter.length > SELECTION_BEFORE_AFTER_TEXT_LENGTH) {\n                    cleanAfter = cleanAfter.substring(0, SELECTION_BEFORE_AFTER_TEXT_LENGTH);\n                }\n            } catch (ex2) {\n                console.log(ex2);\n            }\n        }\n\n        if (currentParent.tagName?.toLowerCase() === \"body\") {\n            break;\n        }\n        currentParent = currentParent.parentNode as Element;\n    }\n    if (cleanBefore.length) {\n        let j = 0;\n        let i = rawBefore.length - 1;\n        let wasWhiteSpace = false;\n        for (; i >= 0; i--) {\n            const isWhiteSpace = /[\\n\\s]/.test(rawBefore[i]);\n            if (isWhiteSpace && i !== 0 && i !== rawBefore.length - 1 && wasWhiteSpace) {\n                wasWhiteSpace = isWhiteSpace;\n                continue;\n            }\n            wasWhiteSpace = isWhiteSpace;\n            j++;\n            if (j >= cleanBefore.length) {\n                break;\n            }\n        }\n        rawBefore = rawBefore.substring(i, rawBefore.length);\n    }\n    if (cleanAfter.length) {\n        let j = 0;\n        let i = 0;\n        let wasWhiteSpace = false;\n        for (; i < rawAfter.length; i++) {\n            const isWhiteSpace = /[\\n\\s]/.test(rawAfter[i]);\n            if (isWhiteSpace && i !== 0 && i !== rawAfter.length - 1 && wasWhiteSpace) {\n                wasWhiteSpace = isWhiteSpace;\n                continue;\n            }\n            wasWhiteSpace = isWhiteSpace;\n            j++;\n            if (j >= cleanAfter.length) {\n                break;\n            }\n        }\n        rawAfter = rawAfter.substring(0, i + 1);\n    }\n\n    // -----------------\n    const rootElementCfi = computeElementCFI(commonElementAncestor);\n    // console.log(`ROOT CFI: ${rootElementCfi}`);\n    // console.log(commonElementAncestor.outerHTML);\n\n    const startElementCfi = computeElementCFI(startContainerElement);\n    // console.log(`START CFI: ${startElementCfi}`);\n    // console.log(startContainerElement.outerHTML);\n\n    const endElementCfi = computeElementCFI(endContainerElement);\n    // console.log(`END CFI: ${endElementCfi}`);\n    // console.log(endContainerElement.outerHTML);\n\n    let cfi: string | undefined;\n\n    if (rootElementCfi && startElementCfi && endElementCfi) {\n        let startElementOrTextCfi = startElementCfi;\n        if (!startIsElement) {\n            const startContainerChildTextNodeIndexForCfi =\n                getChildTextNodeCfiIndex(startContainerElement, range.startContainer as Text);\n            // startContainerChildTextNodeIndex ===\n            // Array.from(startContainerElement.childNodes).indexOf(range.startContainer as ChildNode)\n            startElementOrTextCfi = startElementCfi + \"/\" +\n                startContainerChildTextNodeIndexForCfi + \":\" + range.startOffset;\n        } else {\n            if (range.startOffset >= 0 && range.startOffset < startContainerElement.childNodes.length) {\n                const childNode = startContainerElement.childNodes[range.startOffset];\n                if (childNode.nodeType === Node.ELEMENT_NODE) {\n                    startElementOrTextCfi = startElementCfi + \"/\" + ((range.startOffset + 1) * 2);\n                } else {\n                    const cfiTextNodeIndex = getChildTextNodeCfiIndex(startContainerElement, childNode as Text);\n                    startElementOrTextCfi = startElementCfi + \"/\" + cfiTextNodeIndex; // + \":0\";\n                }\n            } else {\n                const cfiIndexOfLastElement = ((startContainerElement.childElementCount) * 2);\n                const lastChildNode = startContainerElement.childNodes[startContainerElement.childNodes.length - 1];\n                if (lastChildNode.nodeType === Node.ELEMENT_NODE) {\n                    startElementOrTextCfi = startElementCfi + \"/\" + (cfiIndexOfLastElement + 1);\n                } else {\n                    startElementOrTextCfi = startElementCfi + \"/\" + (cfiIndexOfLastElement + 2);\n                }\n            }\n        }\n        // console.log(`START TEXT CFI: ${startTextCfi}`);\n\n        let endElementOrTextCfi = endElementCfi;\n        if (!endIsElement) {\n            const endContainerChildTextNodeIndexForCfi =\n                getChildTextNodeCfiIndex(endContainerElement, range.endContainer as Text);\n            // endContainerChildTextNodeIndex ===\n            // Array.from(endContainerElement.childNodes).indexOf(range.endContainer as ChildNode)\n            endElementOrTextCfi = endElementCfi + \"/\" +\n                endContainerChildTextNodeIndexForCfi + \":\" + range.endOffset;\n        } else {\n            if (range.endOffset >= 0 && range.endOffset < endContainerElement.childNodes.length) {\n                const childNode = endContainerElement.childNodes[range.endOffset];\n                if (childNode.nodeType === Node.ELEMENT_NODE) {\n                    endElementOrTextCfi = endElementCfi + \"/\" + ((range.endOffset + 1) * 2);\n                } else {\n                    const cfiTextNodeIndex = getChildTextNodeCfiIndex(endContainerElement, childNode as Text);\n                    endElementOrTextCfi = endElementCfi + \"/\" + cfiTextNodeIndex; // + \":0\";\n                }\n            } else {\n                const cfiIndexOfLastElement = ((endContainerElement.childElementCount) * 2);\n                const lastChildNode = endContainerElement.childNodes[endContainerElement.childNodes.length - 1];\n                if (lastChildNode.nodeType === Node.ELEMENT_NODE) {\n                    endElementOrTextCfi = endElementCfi + \"/\" + (cfiIndexOfLastElement + 1);\n                } else {\n                    endElementOrTextCfi = endElementCfi + \"/\" + (cfiIndexOfLastElement + 2);\n                }\n            }\n        }\n        // console.log(`END TEXT CFI: ${endTextCfi}`);\n\n        cfi = rootElementCfi + \",\" +\n            startElementOrTextCfi.replace(rootElementCfi, \"\") + \",\" +\n            endElementOrTextCfi.replace(rootElementCfi, \"\");\n    }\n    // -----------------\n    return [{\n        cfi,\n\n        endContainerChildTextNodeIndex,\n        endContainerElementCFI: endElementCfi,\n        endContainerElementCssSelector,\n        endOffset: range.endOffset,\n\n        startContainerChildTextNodeIndex,\n        startContainerElementCFI: startElementCfi,\n        startContainerElementCssSelector,\n        startOffset: range.startOffset,\n    }, {\n        cleanBefore,\n        cleanText,\n        cleanAfter,\n\n        rawBefore,\n        rawText,\n        rawAfter,\n    }];\n}\n\nexport function convertRangeInfo(documant: Document, rangeInfo: IRangeInfo):\n    Range | undefined {\n\n    const startElement = documant.querySelector(rangeInfo.startContainerElementCssSelector);\n    if (!startElement) {\n        console.log(\"^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!\", rangeInfo.startContainerElementCssSelector);\n        return undefined;\n    }\n    let startContainer: Node = startElement;\n    if (rangeInfo.startContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length) {\n            // tslint:disable-next-line:max-line-length\n            console.log(\"^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!\");\n            return undefined;\n        }\n        startContainer = startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            console.log(\"^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!\");\n            return undefined;\n        }\n    }\n    const endElement = documant.querySelector(rangeInfo.endContainerElementCssSelector);\n    if (!endElement) {\n        console.log(\"^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!\", rangeInfo.endContainerElementCssSelector);\n        return undefined;\n    }\n    let endContainer: Node = endElement;\n    if (rangeInfo.endContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length) {\n            // tslint:disable-next-line:max-line-length\n            console.log(\"^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!\");\n            return undefined;\n        }\n        endContainer = endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            console.log(\"^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!\");\n            return undefined;\n        }\n    }\n\n    return createOrderedRange(startContainer, rangeInfo.startOffset, endContainer, rangeInfo.endOffset);\n}\n\nfunction getCommonAncestorElement(node1: Node, node2: Node): Element | undefined {\n    if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {\n        return node1 as Element;\n    }\n\n    if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {\n        return node1 as Element;\n    }\n\n    if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {\n        return node2 as Element;\n    }\n\n    const node1ElementAncestorChain: Element[] = [];\n    let parent: Node | null = node1.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node1ElementAncestorChain.push(parent as Element);\n        parent = parent.parentNode;\n    }\n\n    const node2ElementAncestorChain: Element[] = [];\n    parent = node2.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node2ElementAncestorChain.push(parent as Element);\n        parent = parent.parentNode;\n    }\n\n    let commonAncestor = node1ElementAncestorChain.find((node1ElementAncestor) => {\n        return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;\n    });\n    if (!commonAncestor) {\n        commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {\n            return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;\n        });\n    }\n\n    return commonAncestor;\n}\n\nfunction isCfiTextNode(node: Node) {\n    return node.nodeType !== Node.ELEMENT_NODE;\n    // return node.nodeType === Node.TEXT_NODE ||\n    //     node.nodeType === Node.COMMENT_NODE ||\n    //     node.nodeType === Node.CDATA_SECTION_NODE; // other?\n}\nfunction getChildTextNodeCfiIndex(element: Element, child: Text): number {\n    let found = -1;\n    let textNodeIndex = -1;\n    let previousWasElement = false;\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < element.childNodes.length; i++) {\n        const childNode = element.childNodes[i];\n        const isText = isCfiTextNode(childNode);\n        if (isText || previousWasElement) {\n            textNodeIndex += 2;\n        }\n        if (isText) {\n            if (childNode === child) {\n                found = textNodeIndex;\n                break;\n            }\n        }\n        previousWasElement = childNode.nodeType === Node.ELEMENT_NODE;\n    }\n    return found;\n}\n\n// function getChildTextNode(element: Element, index: number): Text | undefined {\n\n//     let i = -1;\n//     for (const childNode of element.childNodes) {\n//         if (i > index) {\n//             return undefined;\n//         }\n//         if (childNode.nodeType === Node.TEXT_NODE) {\n//             i++;\n//             if (i === index) {\n//                 return childNode as Text;\n//             }\n//         }\n//     }\n\n//     return undefined;\n// }\n\n// function getChildTextNodeIndex(element: Element, child: Text, forCfi: boolean): number {\n//     let found = -1;\n//     let textNodeIndex = -1;\n//     let previousWasElement = false;\n//     // tslint:disable-next-line:prefer-for-of\n//     for (let i = 0; i < element.childNodes.length; i++) {\n//         const childNode = element.childNodes[i];\n//         if (childNode.nodeType !== Node.TEXT_NODE && childNode.nodeType !== Node.ELEMENT_NODE) {\n//             continue;\n//         }\n//         if (forCfi) {\n//             if (childNode.nodeType === Node.TEXT_NODE || previousWasElement) {\n//                 textNodeIndex += 2;\n//             }\n//         }\n//         if (childNode.nodeType === Node.TEXT_NODE) {\n//             if (!forCfi) {\n//                 textNodeIndex++;\n//             }\n\n//             if (childNode === child) {\n//                 found = textNodeIndex;\n//                 break;\n//             }\n//         }\n//         previousWasElement = childNode.nodeType === Node.ELEMENT_NODE;\n//     }\n//     return found;\n// }\n\n//  https://github.com/webmodules/range-normalize/pull/2\n//  \"Normalizes\" the DOM Range instance, such that slight variations in the start\n//  and end containers end up being normalized to the same \"base\" representation.\n//  The aim is to always have `startContainer` and `endContainer` pointing to\n//  TextNode instances.\n//  Pseudo-logic is as follows:\n//  - Expand the boundaries if they fall between siblings.\n//  - Narrow the boundaries until they point at leaf nodes.\n//  - Is the start container excluded by its offset?\n//    - Move it to the next leaf Node, but not past the end container.\n//    - Is the start container a leaf Node but not a TextNode?\n//      - Set the start boundary to be before the Node.\n//  - Is the end container excluded by its offset?\n//    - Move it to the previous leaf Node, but not past the start container.\n//    - Is the end container a leaf Node but not a TextNode?\n//      - Set the end boundary to be after the Node.\n//  @param {Range} range - DOM Range instance to \"normalize\"\n//  @return {Range} returns a \"normalized\" clone of `range`\nexport function normalizeRange(r: Range) {\n\n    const range = r.cloneRange(); // new Range(); // document.createRange()\n\n    let sc = range.startContainer;\n    let so = range.startOffset;\n    let ec = range.endContainer;\n    let eo = range.endOffset;\n\n    // Move the start container to the last leaf before any sibling boundary.\n    if (sc.childNodes.length && so > 0) {\n        sc = lastLeaf(sc.childNodes[so - 1]);\n        so = (sc as CharacterData).length || 0;\n    }\n\n    // Move the end container to the first leaf after any sibling boundary.\n    if (eo < ec.childNodes.length) {\n        ec = firstLeaf(ec.childNodes[eo]);\n        eo = 0;\n    }\n\n    // Move each container inward until it reaches a leaf Node.\n    let start: Node | null = firstLeaf(sc);\n    let end: Node | null = lastLeaf(ec);\n\n    // Define a predicate to check if a Node is a leaf Node inside the Range.\n    function isLeafNodeInRange(node: Node): boolean {\n        if (node.childNodes.length) {\n            return false;\n        }\n\n        const length = (node as CharacterData).length || 0;\n        if (node === sc && so === length) {\n            return false;\n        }\n        if (node === ec && eo === 0) {\n            return false;\n        }\n        return true;\n    }\n\n    // Move the start container until it is included or collapses to the end.\n    while (start && !isLeafNodeInRange(start) && start !== end) {\n        start = documentForward(start);\n    }\n\n    if (start === sc) {\n        range.setStart(sc, so);\n    } else if (start !== null) {\n        if (start.nodeType === 3) {\n            range.setStart(start, 0);\n        } else {\n            range.setStartBefore(start);\n        }\n    }\n\n    // Move the end container until it is included or collapses to the start.\n    while (end && !isLeafNodeInRange(end) && end !== start) {\n        end = documentReverse(end);\n    }\n\n    if (end === ec) {\n        range.setEnd(ec, eo);\n    } else if (end !== null) {\n        if (end.nodeType === 3) {\n            range.setEnd(end, (end as CharacterData).length);\n        } else {\n            range.setEndAfter(end);\n        }\n    }\n\n    return range;\n}\n\n// Return the next Node in a document order traversal.\n// This order is equivalent to a classic pre-order.\nfunction documentForward(node: Node): Node | null {\n    if (node.firstChild) {\n        return node.firstChild;\n    }\n\n    let n: Node | null = node;\n    while (!n.nextSibling) {\n        n = n.parentNode;\n        if (!n) {\n            return null;\n        }\n    }\n\n    return n.nextSibling;\n}\n\n// Return the next Node in a reverse document order traversal.\n// This order is equivalent to pre-order with the child order reversed.\nfunction documentReverse(node: Node): Node | null {\n    if (node.lastChild) {\n        return node.lastChild;\n    }\n\n    let n: Node | null = node;\n    while (!n.previousSibling) {\n        n = n.parentNode;\n        if (!n) {\n            return null;\n        }\n    }\n\n    return n.previousSibling;\n}\n\nfunction firstLeaf(node: Node): Node {\n    while (node.firstChild) {\n        node = node.firstChild;\n    }\n    return node;\n}\n\nfunction lastLeaf(node: Node): Node {\n    while (node.lastChild) {\n        node = node.lastChild;\n    }\n    return node;\n}\n"]}