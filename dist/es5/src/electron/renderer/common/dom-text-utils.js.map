{"version":3,"file":"dom-text-utils.js","sourceRoot":"","sources":["../../../../../../src/electron/renderer/common/dom-text-utils.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport { split } from \"sentence-splitter\";\n\nimport { uniqueCssSelector } from \"../common/cssselector2\";\n\nexport function getLanguage(el: Element): string | undefined {\n\n    let currentElement = el;\n\n    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {\n\n        let lang = currentElement.getAttribute(\"xml:lang\");\n        if (!lang) {\n            lang = currentElement.getAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"lang\");\n        }\n        if (!lang) {\n            lang = currentElement.getAttribute(\"lang\");\n        }\n        if (lang) {\n            return lang;\n        }\n\n        currentElement = currentElement.parentNode as Element;\n    }\n\n    return undefined;\n}\n\nexport function getDirection(el: Element): string | undefined {\n\n    let currentElement = el;\n\n    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {\n\n        const dir = currentElement.getAttribute(\"dir\");\n        if (dir) {\n            return dir;\n        }\n\n        currentElement = currentElement.parentNode as Element;\n    }\n\n    return undefined;\n}\n\nexport function normalizeText(str: string): string {\n    // tslint:disable-next-line:max-line-length\n    return str.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\\n/g, \" \").replace(/\\s\\s+/g, \" \"); // no trim(), we collapse multiple whitespaces into single, preserving prefix and suffix (if any)\n}\n\nexport interface ITtsQueueItem {\n    dir: string | undefined;\n    lang: string | undefined;\n    parentElement: Element;\n    textNodes: Node[];\n    combinedText: string; // combineText(this.textNodes)\n    combinedTextSentences: string[] | undefined;\n}\n\nexport interface ITtsQueueItemReference {\n    item: ITtsQueueItem;\n    iArray: number; // ITtsQueueItem[]\n    iSentence: number; // ITtsQueueItem.combinedTextSentences\n    iGlobal: number; // ITtsQueueItem[] and ITtsQueueItem.combinedTextSentences\n}\n\nexport function consoleLogTtsQueueItem(i: ITtsQueueItem) {\n    console.log(\"<<----\");\n    console.log(i.dir);\n    console.log(i.lang);\n    const cssSelector = uniqueCssSelector(i.parentElement, i.parentElement.ownerDocument as Document);\n    console.log(cssSelector);\n    console.log(i.parentElement.tagName);\n    console.log(i.combinedText);\n    if (i.combinedTextSentences) {\n        console.log(\".......\");\n        for (const j of i.combinedTextSentences) {\n            console.log(j);\n        }\n        console.log(\".......\");\n    }\n    console.log(\"---->>\");\n}\nexport function consoleLogTtsQueue(f: ITtsQueueItem[]) {\n    for (const i of f) {\n        consoleLogTtsQueueItem(i);\n    }\n}\n\nexport function getTtsQueueLength(items: ITtsQueueItem[]) {\n    let l = 0;\n    for (const it of items) {\n        if (it.combinedTextSentences) {\n            l += it.combinedTextSentences.length;\n        } else {\n            l++;\n        }\n    }\n    return l;\n}\n\nexport function getTtsQueueItemRefText(obj: ITtsQueueItemReference): string {\n    if (obj.iSentence === -1) {\n        return obj.item.combinedText;\n    }\n    if (obj.item.combinedTextSentences) {\n        return obj.item.combinedTextSentences[obj.iSentence];\n    }\n    return \"\";\n}\n\nexport function getTtsQueueItemRef(items: ITtsQueueItem[], index: number): ITtsQueueItemReference | undefined {\n    let i = -1;\n    let k = -1;\n    for (const it of items) {\n        k++;\n        if (it.combinedTextSentences) {\n            let j = -1;\n            for (const _sent of it.combinedTextSentences) {\n                j++;\n                i++;\n                if (index === i) {\n                    return { item: it, iArray: k, iGlobal: i, iSentence: j };\n                }\n            }\n        } else {\n            i++;\n            if (index === i) {\n                return { item: it, iArray: k, iGlobal: i, iSentence: -1 };\n            }\n        }\n    }\n    return undefined;\n}\n\nexport function findTtsQueueItemIndex(ttsQueue: ITtsQueueItem[], element: Element, rootElem: Element): number {\n    let i = 0;\n    for (const ttsQueueItem of ttsQueue) {\n        if (element === ttsQueueItem.parentElement ||\n            (ttsQueueItem.parentElement !== (element.ownerDocument as Document).body &&\n                ttsQueueItem.parentElement !== rootElem &&\n                ttsQueueItem.parentElement.contains(element)) ||\n            element.contains(ttsQueueItem.parentElement)) {\n            return i;\n        }\n        if (ttsQueueItem.combinedTextSentences) {\n            i += ttsQueueItem.combinedTextSentences.length;\n        } else {\n            i++;\n        }\n    }\n    return -1;\n}\n\nexport function generateTtsQueue(rootElement: Element): ITtsQueueItem[] {\n\n    const ttsQueue: ITtsQueueItem[] = [];\n    const elementStack: Element[] = [];\n\n    function processTextNode(textNode: Node) {\n\n        if (textNode.nodeType !== Node.TEXT_NODE) {\n            return;\n        }\n        // test for word regexp?  || !/\\w/.test(textNode.nodeValue)\n        if (!textNode.nodeValue || !textNode.nodeValue.trim().length) {\n            return;\n        }\n        const parentElement = elementStack[elementStack.length - 1];\n        if (!parentElement) {\n            return;\n        }\n\n        const lang = textNode.parentElement ? getLanguage(textNode.parentElement) : undefined;\n        const dir = textNode.parentElement ? getDirection(textNode.parentElement) : undefined;\n\n        let current = ttsQueue[ttsQueue.length - 1];\n        if (!current || current.parentElement !== parentElement || current.lang !== lang || current.dir !== dir) {\n            current = {\n                combinedText: \"\", // filled in later (see trySplitTexts())\n                combinedTextSentences: undefined, // filled in later, if text is further chunkable\n                dir,\n                lang,\n                parentElement,\n                textNodes: [],\n            };\n            ttsQueue.push(current);\n        }\n        current.textNodes.push(textNode);\n    }\n\n    let first = true;\n    function processElement(element: Element) {\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n            return;\n        }\n\n        // tslint:disable-next-line:max-line-length\n        const isIncluded = first || element.matches(\"h1, h2, h3, h4, h5, h6, p, th, td, caption, li, blockquote, q, dt, dd, figcaption, div, pre\");\n        first = false;\n        if (isIncluded) {\n            elementStack.push(element);\n        }\n\n        for (const childNode of element.childNodes) {\n            switch (childNode.nodeType) {\n                case Node.ELEMENT_NODE:\n\n                    // tslint:disable-next-line:max-line-length\n                    const isExcluded = (childNode as Element).matches(\"img, sup, sub, audio, video, source, button, canvas, del, dialog, embed, form, head, iframe, meter, noscript, object, s, script, select, style, textarea\");\n                    // code, nav, dl, figure, table, ul, ol\n                    if (!isExcluded) {\n                        processElement(childNode as Element);\n                    }\n                    break;\n                case Node.TEXT_NODE:\n                    if (elementStack.length !== 0) {\n                        processTextNode(childNode);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (isIncluded) {\n            elementStack.pop();\n        }\n    }\n\n    processElement(rootElement);\n\n    function combineTextNodes(textNodes: Node[]): string {\n        if (textNodes && textNodes.length) {\n            let str = \"\";\n            for (const textNode of textNodes) {\n                if (textNode.nodeValue) { // excludes purely-whitespace text nodes\n                    // normalizeText() preserves prefix/suffix whitespace (collapsed to single)\n                    // if (str.length) {\n                    //     str += \" \";\n                    // }\n                    str += normalizeText(textNode.nodeValue);\n                }\n            }\n            return str;\n        }\n        return \"\";\n    }\n\n    function finalizeTextNodes(ttsQueueItem: ITtsQueueItem) {\n        ttsQueueItem.combinedText = combineTextNodes(ttsQueueItem.textNodes).trim();\n        try {\n            const sentences = split(ttsQueueItem.combinedText);\n            ttsQueueItem.combinedTextSentences = [];\n            for (const sentence of sentences) {\n                if (sentence.type === \"Sentence\") {\n                    ttsQueueItem.combinedTextSentences.push(sentence.raw);\n                }\n            }\n            if (ttsQueueItem.combinedTextSentences.length === 0 || ttsQueueItem.combinedTextSentences.length === 1) {\n                ttsQueueItem.combinedTextSentences = undefined;\n            } else {\n                // let total = 0;\n                // ttsQueueItem.combinedTextSentences.forEach((sent) => {\n                //     total += sent.length;\n                // });\n                // const expectedWhiteSpacesSeparators = ttsQueueItem.combinedTextSentences.length - 1;\n                // if (total !== ttsQueueItem.combinedText.length &&\n                //     ((ttsQueueItem.combinedText.length - total) !== expectedWhiteSpacesSeparators)) {\n                //     console.log(\"sentences total !== item.combinedText.length\");\n                //     console.log(total + \" !== \" + ttsQueueItem.combinedText.length);\n                //     consoleLogTtsQueueItem(ttsQueueItem);\n                //     console.log(JSON.stringify(sentences, null, 4));\n                // }\n            }\n        } catch (err) {\n            console.log(err);\n            ttsQueueItem.combinedTextSentences = undefined;\n        }\n    }\n\n    for (const ttsQueueItem of ttsQueue) {\n        finalizeTextNodes(ttsQueueItem);\n    }\n\n    return ttsQueue;\n}\n\n// tslint:disable-next-line:max-line-length\nexport function wrapHighlight(doHighlight: boolean, ttsQueueItemRef: ITtsQueueItemReference, cssClassParent: string, cssClassSpan: string, _cssClassSubSpan: string, word: string | undefined, _start: number, _end: number) {\n\n    // TODO\n    if (typeof word !== \"undefined\") {\n        // console.log(word);\n        // console.log(start);\n        // console.log(end);\n        // console.log(cssClassSubSpan);\n\n        // ttsQueueItem.textNodes.forEach((txtNode) ...\n        // check that txtNode already has cssClassSpan parent (otherwise, abort)\n        // txt = normalizeText(txtNode.nodeValue)\n        // (remember: combineText() inserted \" \" space between each txtNode)\n        // match txt inside ttsQueueItemRef.item.combinedTextSentences (if ttsQueueItemRef.iSentence)\n        // or inside ttsQueueItemRef.item.combinedText\n        // if match then locate word/start/end\n        // if located then split txtNode (if needed) in order to insert span for word (cssClassSubSpan)\n        // attach new nodes to txtNode, so they can be restored (un-highlight)\n        // TXT_SPAN_TXT or TXT_SPAN or SPAN_TXT or SPAN (no split, whole word)\n        return;\n    }\n\n    const ttsQueueItem = ttsQueueItemRef.item;\n\n    if (ttsQueueItem.parentElement) {\n        if (doHighlight) {\n            if (!ttsQueueItem.parentElement.classList.contains(cssClassParent)) {\n                ttsQueueItem.parentElement.classList.add(cssClassParent);\n            }\n        } else {\n            if (ttsQueueItem.parentElement.classList.contains(cssClassParent)) {\n                ttsQueueItem.parentElement.classList.remove(cssClassParent);\n            }\n        }\n    }\n\n    ttsQueueItem.textNodes.forEach((txtNode) => {\n        if (!txtNode.parentElement) {\n            return; // continue\n        }\n        if (doHighlight) {\n            if (txtNode.parentElement.tagName.toLowerCase() !== \"span\" ||\n                !txtNode.parentElement.classList.contains(cssClassSpan)) {\n\n                const span = (txtNode.ownerDocument as Document).createElement(\"span\");\n                span.setAttribute(\"class\", cssClassSpan);\n                txtNode.parentElement.replaceChild(span, txtNode);\n                span.appendChild(txtNode);\n            }\n        } else {\n            if (txtNode.parentElement.tagName.toLowerCase() === \"span\" &&\n                txtNode.parentElement.classList.contains(cssClassSpan)) {\n\n                const span = txtNode.parentElement;\n                span.removeChild(txtNode);\n                if (span.parentElement) {\n                    span.parentElement.replaceChild(txtNode, span);\n                }\n            }\n        }\n    });\n}\n"]}