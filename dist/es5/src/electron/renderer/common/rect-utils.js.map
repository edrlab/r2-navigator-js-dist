{"version":3,"file":"rect-utils.js","sourceRoot":"","sources":["../../../../../../src/electron/renderer/common/rect-utils.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nexport const VERBOSE = false;\nconst IS_DEV = VERBOSE &&\n    (process.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"dev\");\nconst LOG_PREFIX = \"RECTs -- \";\n\nconst logRect = (rect: IRect) => {\n    const LOG_PREFIX_LOCAL = \"logRect ~~ \";\n\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `TOP:${rect.top} BOTTOM:${rect.bottom} LEFT:${rect.left} RIGHT:${rect.right} WIDTH:${rect.width} HEIGHT:${rect.height}`);\n    }\n};\n\n// interface DOMRect extends DOMRectReadOnly {\n//     height: number;\n//     width: number;\n//     x: number;\n//     y: number;\n// }\n// interface ClientRect {\n//     bottom: number;\n//     readonly height: number;\n//     left: number;\n//     right: number;\n//     top: number;\n//     readonly width: number;\n// }\nexport interface IRectSimple {\n    height: number;\n    left: number;\n    top: number;\n    width: number;\n}\nexport interface IRect extends IRectSimple {\n    bottom: number;\n    right: number;\n}\n\nexport function DOMRectListToArray(domRects: DOMRectList): IRect[] {\n    const rects: IRect[] = [];\n    for (const domRect of domRects) {\n        rects.push({\n            bottom: domRect.bottom,\n            height: domRect.height,\n            left: domRect.left,\n            right: domRect.right,\n            top: domRect.top,\n            width: domRect.width,\n        });\n    }\n    return rects;\n}\n\nexport function getTextClientRects(range: Range, elementNamesToSkip?: string[]): IRect[] {\n    // return range.getClientRects();\n\n    const doc = range.commonAncestorContainer.ownerDocument;\n    if (!doc) {\n        return [];\n    }\n\n    const iter = doc.createNodeIterator(\n        range.commonAncestorContainer,\n        NodeFilter.SHOW_TEXT,\n        {\n            acceptNode: (node: Node) => { // Text -- node.nodeType === Node.TEXT_NODE\n                if (node.nodeType === Node.TEXT_NODE && range.intersectsNode(node)) {\n                    if (!elementNamesToSkip) {\n                        return NodeFilter.FILTER_ACCEPT;\n                    }\n                    const parentName = node.parentElement?.nodeName.toLowerCase();\n                    if (!parentName || !elementNamesToSkip.includes(parentName)) {\n                        return NodeFilter.FILTER_ACCEPT;\n                    }\n                }\n                return NodeFilter.FILTER_REJECT;\n            },\n        },\n    );\n\n    const rects: IRect[] = [];\n\n    while (iter.nextNode()) {\n        const r = doc.createRange();\n        if (iter.referenceNode.nodeValue && iter.referenceNode === range.startContainer) {\n            r.setStart(iter.referenceNode, range.startOffset);\n\n            r.setEnd(iter.referenceNode, iter.referenceNode === range.endContainer ? range.endOffset : iter.referenceNode.nodeValue.length);\n        } else if (iter.referenceNode.nodeValue && iter.referenceNode === range.endContainer) {\n            r.setStart(iter.referenceNode, 0);\n\n            r.setEnd(iter.referenceNode, range.endOffset);\n        } else {\n            r.selectNode(iter.referenceNode);\n        }\n\n\n        if (r.collapsed) {\n            continue;\n        }\n\n        const nodeRects = DOMRectListToArray(r.getClientRects());\n        rects.push(...nodeRects);\n\n        // const domRect = r.getBoundingClientRect();\n        // rects.push({\n        //     bottom: domRect.bottom,\n        //     height: domRect.height,\n        //     left: domRect.left,\n        //     right: domRect.right,\n        //     top: domRect.top,\n        //     width: domRect.width,\n        // });\n    }\n\n    // const nextNode = iter.nextNode();\n    // if (!nextNode) {\n    //     return [];\n    // }\n    // if (iter.referenceNode?.nodeType !== Node.TEXT_NODE) {\n    //     return [];\n    // }\n\n    return rects;\n}\n\nexport function getClientRectsNoOverlap(\n    originalRects: IRect[], // not DOMRectList which has [i] and .length, but no iterator for of\n    doNotMergeAlignedRects: boolean,\n    vertical: boolean,\n    expand?: number): IRect[] {\n    const LOG_PREFIX_LOCAL = \"getClientRectsNoOverlap ~~ \";\n\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"original number of rects = \" + originalRects.length);\n    }\n\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"expand = \" + expand);\n    }\n    const ex = expand ? expand : 0;\n    if (ex) {\n        for (const rect of originalRects) {\n            rect.left -= ex;\n            rect.top -= ex;\n            rect.right += ex;\n            rect.bottom += ex;\n            rect.width += (2 * ex);\n            rect.height += (2 * ex);\n        }\n    }\n\n    // horizontal boxes\n    const rectsLandscapeAspectRatio = originalRects.filter((r) => {\n        return r.width >= r.height;\n    });\n    // vertical boxes\n    const rectsPortraitAspectRatio = originalRects.filter((r) => {\n        return r.width < r.height;\n    });\n\n    // negative value, first less than second (r1 < r2)\n    const sortFunc = (r1: IRect, r2: IRect) => {\n        const areaR1 = r1.width * r1.height;\n        const areaR2 = r2.width * r2.height;\n        return areaR1 < areaR2 ? -1 : areaR1 === areaR2 ? 0 : 1;\n    };\n\n    // in-place sort\n    rectsLandscapeAspectRatio.sort(sortFunc);\n    rectsPortraitAspectRatio.sort(sortFunc);\n\n    originalRects = vertical ? rectsPortraitAspectRatio.concat(rectsLandscapeAspectRatio) : rectsLandscapeAspectRatio.concat(rectsPortraitAspectRatio);\n\n    const tolerance = 3;\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"tolerance = \" + tolerance);\n    }\n\n    const mergedRects = mergeTouchingRects(originalRects, tolerance, doNotMergeAlignedRects, vertical);\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"after [mergeTouchingRects], number of rects = \" + mergedRects.length);\n    }\n\n    const noContainedRects = removeContainedRects(mergedRects, tolerance, doNotMergeAlignedRects, vertical);\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"after [removeContainedRects], number of rects = \" + noContainedRects.length);\n    }\n\n    const newRects = replaceOverlapingRects(noContainedRects, doNotMergeAlignedRects, vertical);\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"after [replaceOverlapingRects], number of rects = \" + newRects.length);\n    }\n\n    const minArea = 2 * 2;\n    for (let j = newRects.length - 1; j >= 0; j--) {\n        const rect = newRects[j];\n        let bigEnough = (rect.width * rect.height) > minArea;\n        if (bigEnough && ex && (rect.width <= ex || rect.height <= ex)) {\n            bigEnough = false;\n        }\n        if (!bigEnough) {\n            if (newRects.length > 1) {\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"removed small\");\n                }\n                newRects.splice(j, 1);\n            } else { // newRects.length === 1\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"removed all smalls, but must keep last small one otherwise array empty!\");\n                }\n                break;\n            }\n        }\n    }\n\n    if (IS_DEV) {\n        checkOverlaps(newRects);\n    }\n\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `total reduction ${originalRects.length} --> ${newRects.length}`);\n        for (const r of newRects) {\n            logRect(r);\n        }\n    }\n    return newRects;\n}\n\n// https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/lib/rect-helpers.js\n// https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/lib/tappable-rects.js\nfunction almostEqual(a: number, b: number, tolerance: number) {\n    return Math.abs(a - b) <= tolerance;\n}\n\nexport function rectIntersect(rect1: IRect, rect2: IRect): IRect {\n    const maxLeft = Math.max(rect1.left, rect2.left);\n    const minRight = Math.min(rect1.right, rect2.right);\n    const maxTop = Math.max(rect1.top, rect2.top);\n    const minBottom = Math.min(rect1.bottom, rect2.bottom);\n    const rect: IRect = {\n        bottom: minBottom,\n        height: Math.max(0, minBottom - maxTop),\n        left: maxLeft,\n        right: minRight,\n        top: maxTop,\n        width: Math.max(0, minRight - maxLeft),\n    };\n    return rect;\n}\n\n// rect1 - rect2\nexport function rectSubtract(rect1: IRect, rect2: IRect): IRect[] {\n\n    const rectIntersected = rectIntersect(rect2, rect1);\n    if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n    // if (rectIntersected.left >= rectIntersected.right || rectIntersected.top >= rectIntersected.bottom) {\n        return [rect1];\n    }\n\n    const rects: IRect[] = [];\n\n    {\n        // left strip\n        const rectA: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rect1.left,\n            right: rectIntersected.left,\n            top: rect1.top,\n            width: 0,\n        };\n        rectA.width = rectA.right - rectA.left;\n        rectA.height = rectA.bottom - rectA.top;\n        if (rectA.height !== 0 && rectA.width !== 0) {\n        // if (rectA.left < rectA.right && rectA.top < rectA.bottom) {\n            rects.push(rectA);\n        }\n    }\n\n    {\n        // inside strip\n        const rectB: IRect = {\n            bottom: rectIntersected.top,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectB.width = rectB.right - rectB.left;\n        rectB.height = rectB.bottom - rectB.top;\n        if (rectB.height !== 0 && rectB.width !== 0) {\n        // if (rectB.left < rectB.right && rectB.top < rectB.bottom) {\n            rects.push(rectB);\n        }\n    }\n\n    {\n        // inside strip\n        const rectC: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rectIntersected.bottom,\n            width: 0,\n        };\n        rectC.width = rectC.right - rectC.left;\n        rectC.height = rectC.bottom - rectC.top;\n        if (rectC.height !== 0 && rectC.width !== 0) {\n        // if (rectC.left < rectC.right && rectC.top < rectC.bottom) {\n            rects.push(rectC);\n        }\n    }\n\n    {\n        // right strip\n        const rectD: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.right,\n            right: rect1.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectD.width = rectD.right - rectD.left;\n        rectD.height = rectD.bottom - rectD.top;\n        if (rectD.height !== 0 && rectD.width !== 0) {\n        // if (rectD.left < rectD.right && rectD.top < rectD.bottom) {\n            rects.push(rectD);\n        }\n    }\n\n    return rects;\n}\n\nexport function rectSame(rect1: IRect, rect2: IRect, tolerance: number) {\n    return almostEqual(rect1.left, rect2.left, tolerance) &&\n        almostEqual(rect1.right, rect2.right, tolerance) &&\n        almostEqual(rect1.top, rect2.top, tolerance) &&\n        almostEqual(rect1.bottom, rect2.bottom, tolerance); // width and height implied correct\n}\n\nexport function rectContainsPoint(rect: IRect, x: number, y: number, tolerance: number) {\n    return (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n        (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n        (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n        (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));\n}\n\nexport function rectContains(rect1: IRect, rect2: IRect, tolerance: number) {\n    return (\n        rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) && // top left corner\n        rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) && // top right corner\n        rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) && // bottom left corner\n        rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance) // bottom right corner\n    );\n}\n\nexport function getBoundingRect(rect1: IRect, rect2: IRect): IRect {\n    const left = Math.min(rect1.left, rect2.left);\n    const right = Math.max(rect1.right, rect2.right);\n    const top = Math.min(rect1.top, rect2.top);\n    const bottom = Math.max(rect1.bottom, rect2.bottom);\n    return {\n        bottom,\n        height: bottom - top,\n        left,\n        right,\n        top,\n        width: right - left,\n    };\n}\n\nexport function rectsTouchOrOverlap(rect1: IRect, rect2: IRect, tolerance: number) {\n    return (\n        (rect1.left < rect2.right || (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n        (rect2.left < rect1.right || (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n        (rect1.top < rect2.bottom || (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n        (rect2.top < rect1.bottom || (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance)))\n    );\n}\n\nexport function mergeTouchingRects(rects: IRect[], tolerance: number, doNotMergeAlignedRects: boolean, vertical: boolean): IRect[] {\n    const LOG_PREFIX_LOCAL = \"mergeTouchingRects ~~ \";\n\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"rect1 === rect2 ??!\");\n                }\n                continue;\n            }\n\n            // horizontally-stacked lines of characters in vertical flowing text\n            // |=================||======================|\n            // |        1        ||           2          |\n            // |=================||======================|\n            const rectsLineUpVertically =\n                almostEqual(rect1.top, rect2.top, tolerance) &&\n                almostEqual(rect1.bottom, rect2.bottom, tolerance);\n            const mergeAllowedForVerticallyLinedUpRects = !doNotMergeAlignedRects || !vertical;\n\n            // vertically-stacked lines of characters in horizontal flowing text\n            // |=================|\n            // |        1        |\n            // |=================|\n            // |=================|\n            // |                 |\n            // |        2        |\n            // |                 |\n            // |=================|\n            const rectsLineUpHorizontally =\n                almostEqual(rect1.left, rect2.left, tolerance) &&\n                almostEqual(rect1.right, rect2.right, tolerance);\n            const mergeAllowedForHorizontallyLinedUpRects = !doNotMergeAlignedRects || vertical;\n\n            const doMerge =\n                // do not merge same rects (other containment operation elsewhere)\n                (\n                (rectsLineUpVertically && !rectsLineUpHorizontally)\n                ||\n                (!rectsLineUpVertically && rectsLineUpHorizontally)\n                )\n                &&\n                (\n                (rectsLineUpHorizontally && mergeAllowedForHorizontallyLinedUpRects)\n                ||\n                (rectsLineUpVertically && mergeAllowedForVerticallyLinedUpRects)\n                )\n                &&\n                rectsTouchOrOverlap(rect1, rect2, tolerance);\n\n            if (doMerge) {\n                const newRects = rects.filter((rect) => {\n                    return rect !== rect1 && rect !== rect2;\n                });\n                const boundingRect = getBoundingRect(rect1, rect2);\n                newRects.push(boundingRect);\n\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `merged ${rects.length} ==> ${newRects.length}, VERTICAL ALIGN: ${rectsLineUpVertically} HORIZONTAL ALIGN: ${rectsLineUpHorizontally} (DO NOT MERGE: ${doNotMergeAlignedRects}, VERTICAL: ${vertical}) `);\n                    logRect(rect1);\n                    console.log(\"+\");\n                    logRect(rect2);\n                    console.log(\"=\");\n                    logRect(boundingRect);\n                }\n                return mergeTouchingRects(newRects, tolerance, doNotMergeAlignedRects, vertical);\n            }\n        }\n    }\n\n    return rects;\n}\n\nexport function replaceOverlapingRects(rects: IRect[], doNotMergeAlignedRects: boolean, vertical: boolean): IRect[] {\n    const LOG_PREFIX_LOCAL = \"replaceOverlapingRects ~~ \";\n\n    if (doNotMergeAlignedRects) {\n        return rects;\n    }\n\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"rect1 === rect2 ??!\");\n                }\n                continue;\n            }\n\n            if (!rectsTouchOrOverlap(rect1, rect2, -1)) { // negative tolerance for strict overlap test\n                continue;\n            }\n\n            // horizontally-stacked lines of characters in vertical flowing text\n            // |=================||======================|\n            // |        1        ||           2          |\n            // |=================||======================|\n            // const rectsLineUpVertically =\n            //     almostEqual(possiblyContainingRect.top, rect.top, tolerance) &&\n            //     almostEqual(possiblyContainingRect.bottom, rect.bottom, tolerance);\n            // const mergeAllowedForVerticallyLinedUpRects = !doNotMergeAlignedRects || !vertical;\n\n            // vertically-stacked lines of characters in horizontal flowing text\n            // |=================|\n            // |        1        |\n            // |=================|\n            // |=================|\n            // |                 |\n            // |        2        |\n            // |                 |\n            // |=================|\n            // const rectsLineUpHorizontally =\n            //     almostEqual(possiblyContainingRect.left, rect.left, tolerance) &&\n            //     almostEqual(possiblyContainingRect.right, rect.right, tolerance);\n            // const mergeAllowedForHorizontallyLinedUpRects = !doNotMergeAlignedRects || vertical;\n\n            let toAdd: IRect[] = [];\n            let toRemove: IRect;\n            let toPreserve: IRect;\n\n            let n = 0;\n\n            // rect1 - rect2\n            const subtractRects1 = rectSubtract(rect1, rect2); // discard #1, keep #2, add returned rects\n            if (subtractRects1.length === 1) {\n                n = 1;\n                toAdd = subtractRects1;\n                toRemove = rect1;\n                toPreserve = rect2;\n            } else {\n                // rect2 - rect1\n                const subtractRects2 = rectSubtract(rect2, rect1); // discard #2, keep #1, add returned rects\n                if (subtractRects1.length < subtractRects2.length) {\n                    n = 2;\n                    toAdd = subtractRects1;\n                    toRemove = rect1;\n                    toPreserve = rect2;\n                } else {\n                    n = 3;\n                    toAdd = subtractRects2;\n                    toRemove = rect2;\n                    toPreserve = rect1;\n                }\n            }\n\n            if (IS_DEV) {\n                console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `overlap ${n} ADD: ${toAdd.length}`);\n                for (const r of toAdd) {\n                    logRect(r);\n                }\n                console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `overlap ${n} REMOVE:`);\n                logRect(toRemove);\n                console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `overlap ${n} KEEP:`);\n                logRect(toPreserve);\n            }\n\n            if (IS_DEV) {\n                const toCheck = [];\n                toCheck.push(toPreserve);\n                toCheck.push(...toAdd);\n                checkOverlaps(toCheck);\n            }\n\n            const newRects = rects.filter((rect) => {\n                return rect !== toRemove;\n            });\n            newRects.push(...toAdd);\n\n            if (IS_DEV) {\n                console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `overlap removed: ${rects.length} ==> ${newRects.length}`);\n            }\n\n            return replaceOverlapingRects(newRects, doNotMergeAlignedRects, vertical);\n        }\n    }\n\n    return rects;\n}\n\nexport function getRectOverlapX(rect1: IRect, rect2: IRect) {\n    return Math.max(0, Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left));\n}\n\nexport function getRectOverlapY(rect1: IRect, rect2: IRect) {\n    return Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top));\n}\n\nexport function removeContainedRects(rects: IRect[], tolerance: number, doNotMergeAlignedRects: boolean, vertical: boolean): IRect[] {\n    const LOG_PREFIX_LOCAL = \"removeContainedRects ~~ \";\n\n    const rectsToKeep = new Set(rects);\n\n    for (const rect of rects) {\n        const bigEnough = rect.width > 1 && rect.height > 1;\n        if (!bigEnough) {\n            if (IS_DEV) {\n                console.log(LOG_PREFIX + \"removed tiny:\");\n                logRect(rect);\n            }\n            rectsToKeep.delete(rect);\n            continue;\n        }\n        for (const possiblyContainingRect of rects) {\n            if (rect === possiblyContainingRect) {\n                continue;\n            }\n            if (!rectsToKeep.has(possiblyContainingRect) || !rectsToKeep.has(rect)) {\n                continue;\n            }\n            if (!rectContains(possiblyContainingRect, rect, tolerance)) {\n                continue;\n            }\n\n            if (doNotMergeAlignedRects) {\n\n                // horizontally-stacked lines of characters in vertical flowing text\n                // |=================||======================|\n                // |        1        ||           2          |\n                // |=================||======================|\n                const rectsLineUpVertically =\n                    almostEqual(possiblyContainingRect.top, rect.top, tolerance) &&\n                    almostEqual(possiblyContainingRect.bottom, rect.bottom, tolerance);\n                // const mergeAllowedForVerticallyLinedUpRects = !doNotMergeAlignedRects || !vertical;\n\n                // vertically-stacked lines of characters in horizontal flowing text\n                // |=================|\n                // |        1        |\n                // |=================|\n                // |=================|\n                // |                 |\n                // |        2        |\n                // |                 |\n                // |=================|\n                const rectsLineUpHorizontally =\n                    almostEqual(possiblyContainingRect.left, rect.left, tolerance) &&\n                    almostEqual(possiblyContainingRect.right, rect.right, tolerance);\n                // const mergeAllowedForHorizontallyLinedUpRects = !doNotMergeAlignedRects || vertical;\n\n                if (rectsLineUpVertically && rectsLineUpHorizontally) {\n                    // if same rects, definitely eliminate one\n                    if (IS_DEV) {\n                        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"[identical] removed container (keep contained):\");\n                        logRect(possiblyContainingRect);\n                        logRect(rect);\n                    }\n                    rectsToKeep.delete(possiblyContainingRect);\n                    // break;\n                    continue;\n                } else if (rectsLineUpVertically || rectsLineUpHorizontally) {\n                    if (rectsLineUpVertically && !vertical || rectsLineUpHorizontally && vertical) {\n                        if (IS_DEV) {\n                            console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"[aligned] removed contained (keep container):\");\n                            logRect(rect);\n                            logRect(possiblyContainingRect);\n                        }\n                        rectsToKeep.delete(rect);\n                        // break;\n                        continue;\n                    }\n\n                    continue;\n                }\n            } else {\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"[merge yes] removed contained (keep container):\");\n                    logRect(rect);\n                    logRect(possiblyContainingRect);\n                }\n                rectsToKeep.delete(rect);\n            }\n            // break;\n            continue;\n        }\n    }\n\n    return Array.from(rectsToKeep);\n}\n\nexport function checkOverlaps(rects: IRect[]) {\n    const LOG_PREFIX_LOCAL = \"checkOverlaps ~~ \";\n\n    const stillOverlapingRects: IRect[] = [];\n\n    for (const rect1 of rects) {\n        for (const rect2 of rects) {\n            if (rect1 === rect2) {\n                continue;\n            }\n\n            const has1 = stillOverlapingRects.includes(rect1);\n            const has2 = stillOverlapingRects.includes(rect2);\n            if (!has1 || !has2) {\n                if (rectsTouchOrOverlap(rect1, rect2, -1)) { // negative tolerance for strict overlap test\n\n                    if (!has1) {\n                        stillOverlapingRects.push(rect1);\n                    }\n                    if (!has2) {\n                        stillOverlapingRects.push(rect2);\n                    }\n\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"RECT 1:\");\n                    logRect(rect1);\n\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"RECT 2:\");\n                    logRect(rect2);\n\n                    const xOverlap = getRectOverlapX(rect1, rect2);\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `X overlap: ${xOverlap}`);\n\n                    const yOverlap = getRectOverlapY(rect1, rect2);\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `Y overlap: ${yOverlap}`);\n                }\n            }\n        }\n    }\n\n    if (stillOverlapingRects.length) {\n        if (IS_DEV) {\n            console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `still overlaping = ${stillOverlapingRects.length}`);\n        }\n    }\n}\n\n// https://github.com/edg2s/rangefix/blob/master/rangefix.js\n// function checkRangeFix(documant: Document) {\n\n//     const p = documant.createElement(\"p\");\n//     const span = documant.createElement(\"span\");\n//     const t1 = documant.createTextNode(\"aa\");\n//     const t2 = documant.createTextNode(\"aa\");\n//     const img = documant.createElement(\"img\");\n//     img.setAttribute(\"src\", \"#null\");\n//     p.appendChild(t1);\n//     p.appendChild(span);\n//     span.appendChild(img);\n//     span.appendChild(t2);\n//     documant.body.appendChild( p );\n\n//     const range = new Range(); // documant.createRange();\n//     range.setStart(t1, 1);\n//     range.setEnd(span, 0);\n\n//     let getBoundingClientRect = range.getClientRects().length > 1;\n//     let getClientRects = getBoundingClientRect;\n//     console.log(LOG_PREFIX + \"BUG 1: \" + getClientRects);\n\n//     if (!getClientRects) {\n//         range.setEnd(t2, 1);\n//         getBoundingClientRect = range.getClientRects().length === 2;\n//         getClientRects = getBoundingClientRect;\n//         console.log(LOG_PREFIX + \"BUG 2: \" + getClientRects);\n//     }\n\n//     if (!getBoundingClientRect) {\n//         // Safari doesn't return a valid bounding rect for collapsed ranges\n//         // Equivalent to range.collapse( true ) which isn't well supported\n//         range.setEnd(range.startContainer, range.startOffset);\n//         const boundingRect = range.getBoundingClientRect();\n//         getBoundingClientRect = boundingRect.top === 0 && boundingRect.left === 0;\n//         console.log(LOG_PREFIX + \"BUG 3: \" + getBoundingClientRect);\n//     }\n\n//     documant.body.removeChild(p);\n// }\n\n// function getClientRectsFix(range: Range): ClientRect[] | DOMRect[] {\n\n//     const rects: ClientRect[] | DOMRect[] = [];\n\n//     let endContainer: Node | null = range.endContainer;\n//     let endOffset: number = range.endOffset;\n//     let partialRange = new Range();\n\n//     while (endContainer && endContainer !== range.commonAncestorContainer) {\n//         partialRange.setStart(endContainer, 0);\n//         partialRange.setEnd(endContainer, endOffset);\n\n//         Array.prototype.push.apply(rects, partialRange.getClientRects());\n\n//         const parentNode: Node | null = endContainer.parentNode;\n//         if (parentNode) {\n//             endOffset = Array.prototype.indexOf.call(parentNode.childNodes, endContainer);\n//         }\n//         endContainer = parentNode;\n//     }\n\n//     if (endContainer) {\n//         partialRange = range.cloneRange();\n//         partialRange.setEnd(endContainer, endOffset);\n//         Array.prototype.push.apply(rects, partialRange.getClientRects());\n//     }\n\n//     return rects;\n// }\n\n// function getBoundingClientRectFix(range: Range): ClientRect | DOMRect | undefined {\n\n//     const rects = getClientRectsFix(range);\n//     if (rects.length === 0) {\n//         return undefined;\n//     }\n\n//     const nativeBoundingRect = range.getBoundingClientRect();\n//     if (nativeBoundingRect.width === 0 && nativeBoundingRect.height === 0) {\n//         return rects[0];\n//     }\n\n//     let boundingRect: ClientRect | undefined;\n\n//     for (const rect of rects) {\n//         if (!boundingRect) {\n//             boundingRect = {\n//                 bottom: rect.bottom,\n//                 height: rect.bottom - rect.top,\n//                 left: rect.left,\n//                 right: rect.right,\n//                 top: rect.top,\n//                 width: rect.right - rect.left,\n//             };\n//         } else {\n//             boundingRect.left = Math.min(boundingRect.left, rect.left);\n//             boundingRect.top = Math.min(boundingRect.top, rect.top);\n//             boundingRect.right = Math.max(boundingRect.right, rect.right);\n//             boundingRect.bottom = Math.max(boundingRect.bottom, rect.bottom);\n//             (boundingRect as any).width = boundingRect.right - boundingRect.left;\n//             (boundingRect as any).height = boundingRect.bottom - boundingRect.top;\n//         }\n//     }\n\n//     return boundingRect;\n// }\n"]}