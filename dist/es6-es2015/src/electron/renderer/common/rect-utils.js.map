{"version":3,"file":"rect-utils.js","sourceRoot":"","sources":["../../../../../../src/electron/renderer/common/rect-utils.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nexport const VERBOSE = false;\nconst IS_DEV = VERBOSE &&\n    (process.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"dev\");\nconst LOG_PREFIX = \"RECTs -- \";\n\nconst logRect = (rect: IRect) => {\n    const LOG_PREFIX_LOCAL = \"logRect ~~ \";\n\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `TOP:${rect.top} BOTTOM:${rect.bottom} LEFT:${rect.left} RIGHT:${rect.right} WIDTH:${rect.width} HEIGHT:${rect.height}`);\n    }\n};\n\n// interface DOMRect extends DOMRectReadOnly {\n//     height: number;\n//     width: number;\n//     x: number;\n//     y: number;\n// }\n// interface ClientRect {\n//     bottom: number;\n//     readonly height: number;\n//     left: number;\n//     right: number;\n//     top: number;\n//     readonly width: number;\n// }\nexport interface IRectSimple {\n    height: number;\n    left: number;\n    top: number;\n    width: number;\n}\nexport interface IRect extends IRectSimple {\n    bottom: number;\n    right: number;\n}\n\nexport function DOMRectListToArray(domRects: DOMRectList): IRect[] {\n    const rects: IRect[] = [];\n    for (const domRect of domRects) {\n        rects.push({\n            bottom: domRect.bottom,\n            height: domRect.height,\n            left: domRect.left,\n            right: domRect.right,\n            top: domRect.top,\n            width: domRect.width,\n        });\n    }\n    return rects;\n}\n\nexport function getTextClientRects(range: Range, elementNamesToSkip?: string[]): IRect[] {\n    // return range.getClientRects();\n\n    const doc = range.commonAncestorContainer.ownerDocument;\n    if (!doc) {\n        return [];\n    }\n\n    const iter = doc.createNodeIterator(\n        range.commonAncestorContainer,\n        NodeFilter.SHOW_TEXT,\n        {\n            acceptNode: (node: Node) => { // Text -- node.nodeType === Node.TEXT_NODE\n                if (node.nodeType === Node.TEXT_NODE && range.intersectsNode(node)) {\n                    if (!elementNamesToSkip) {\n                        return NodeFilter.FILTER_ACCEPT;\n                    }\n                    const parentName = node.parentElement?.nodeName.toLowerCase();\n                    if (!parentName || !elementNamesToSkip.includes(parentName)) {\n                        return NodeFilter.FILTER_ACCEPT;\n                    }\n                }\n                return NodeFilter.FILTER_REJECT;\n            },\n        },\n    );\n\n    const rects: IRect[] = [];\n\n    while (iter.nextNode()) {\n        const r = doc.createRange();\n        if (iter.referenceNode.nodeValue && iter.referenceNode === range.startContainer) {\n            r.setStart(iter.referenceNode, range.startOffset);\n\n            r.setEnd(iter.referenceNode, iter.referenceNode === range.endContainer ? range.endOffset : iter.referenceNode.nodeValue.length);\n        } else if (iter.referenceNode.nodeValue && iter.referenceNode === range.endContainer) {\n            r.setStart(iter.referenceNode, 0);\n\n            r.setEnd(iter.referenceNode, range.endOffset);\n        } else {\n            r.selectNode(iter.referenceNode);\n        }\n\n\n        if (r.collapsed) {\n            continue;\n        }\n\n        const nodeRects = DOMRectListToArray(r.getClientRects());\n        rects.push(...nodeRects);\n\n        // const domRect = r.getBoundingClientRect();\n        // rects.push({\n        //     bottom: domRect.bottom,\n        //     height: domRect.height,\n        //     left: domRect.left,\n        //     right: domRect.right,\n        //     top: domRect.top,\n        //     width: domRect.width,\n        // });\n    }\n\n    // const nextNode = iter.nextNode();\n    // if (!nextNode) {\n    //     return [];\n    // }\n    // if (iter.referenceNode?.nodeType !== Node.TEXT_NODE) {\n    //     return [];\n    // }\n\n    return rects;\n}\n\nexport function getClientRectsNoOverlap(\n    originalRects: IRect[], // not DOMRectList which has [i] and .length, but no iterator for of\n    doNotMergeAlignedRects: boolean,\n    vertical: boolean,\n    expand?: number): IRect[] {\n    const LOG_PREFIX_LOCAL = \"getClientRectsNoOverlap ~~ \";\n\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"original number of rects = \" + originalRects.length);\n    }\n\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"expand = \" + expand);\n    }\n    const ex = expand ? expand : 0;\n    if (ex) {\n        for (const rect of originalRects) {\n            rect.left -= ex;\n            rect.top -= ex;\n            rect.right += ex;\n            rect.bottom += ex;\n            rect.width += (2 * ex);\n            rect.height += (2 * ex);\n        }\n    }\n\n    // horizontal boxes\n    const rectsLandscapeAspectRatio = originalRects.filter((r) => {\n        return r.width >= r.height;\n    });\n    // vertical boxes\n    const rectsPortraitAspectRatio = originalRects.filter((r) => {\n        return r.width < r.height;\n    });\n\n    // negative value, first less than second (r1 < r2)\n    const sortFunc = (r1: IRect, r2: IRect) => {\n        const areaR1 = r1.width * r1.height;\n        const areaR2 = r2.width * r2.height;\n        return areaR1 < areaR2 ? -1 : areaR1 === areaR2 ? 0 : 1;\n    };\n\n    // in-place sort\n    rectsLandscapeAspectRatio.sort(sortFunc);\n    rectsPortraitAspectRatio.sort(sortFunc);\n\n    originalRects = vertical ? rectsPortraitAspectRatio.concat(rectsLandscapeAspectRatio) : rectsLandscapeAspectRatio.concat(rectsPortraitAspectRatio);\n\n    const tolerance = 3;\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"tolerance = \" + tolerance);\n    }\n\n    const mergedRects = mergeTouchingRects(originalRects, tolerance, doNotMergeAlignedRects, vertical);\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"after [mergeTouchingRects], number of rects = \" + mergedRects.length);\n    }\n\n    const noContainedRects = removeContainedRects(mergedRects, tolerance, doNotMergeAlignedRects, vertical);\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"after [removeContainedRects], number of rects = \" + noContainedRects.length);\n    }\n\n    const newRects = replaceOverlapingRects(noContainedRects, doNotMergeAlignedRects, vertical);\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"after [replaceOverlapingRects], number of rects = \" + newRects.length);\n    }\n\n    const minArea = 2 * 2;\n    for (let j = newRects.length - 1; j >= 0; j--) {\n        const rect = newRects[j];\n        let bigEnough = (rect.width * rect.height) > minArea;\n        if (bigEnough && ex && (rect.width <= ex || rect.height <= ex)) {\n            bigEnough = false;\n        }\n        if (!bigEnough) {\n            if (newRects.length > 1) {\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"removed small\");\n                }\n                newRects.splice(j, 1);\n            } else { // newRects.length === 1\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"removed all smalls, but must keep last small one otherwise array empty!\");\n                }\n                break;\n            }\n        }\n    }\n\n    if (IS_DEV) {\n        checkOverlaps(newRects);\n    }\n\n    if (IS_DEV) {\n        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `total reduction ${originalRects.length} --> ${newRects.length}`);\n        for (const r of newRects) {\n            logRect(r);\n        }\n    }\n    return newRects;\n}\n\n// https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/lib/rect-helpers.js\n// https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/lib/tappable-rects.js\nfunction almostEqual(a: number, b: number, tolerance: number) {\n    return Math.abs(a - b) <= tolerance;\n}\n\nexport function rectIntersect(rect1: IRect, rect2: IRect): IRect {\n    const maxLeft = Math.max(rect1.left, rect2.left);\n    const minRight = Math.min(rect1.right, rect2.right);\n    const maxTop = Math.max(rect1.top, rect2.top);\n    const minBottom = Math.min(rect1.bottom, rect2.bottom);\n    const rect: IRect = {\n        bottom: minBottom,\n        height: Math.max(0, minBottom - maxTop),\n        left: maxLeft,\n        right: minRight,\n        top: maxTop,\n        width: Math.max(0, minRight - maxLeft),\n    };\n    return rect;\n}\n\n// rect1 - rect2\nexport function rectSubtract(rect1: IRect, rect2: IRect): IRect[] {\n\n    const rectIntersected = rectIntersect(rect2, rect1);\n    if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n    // if (rectIntersected.left >= rectIntersected.right || rectIntersected.top >= rectIntersected.bottom) {\n        return [rect1];\n    }\n\n    const rects: IRect[] = [];\n\n    {\n        // left strip\n        const rectA: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rect1.left,\n            right: rectIntersected.left,\n            top: rect1.top,\n            width: 0,\n        };\n        rectA.width = rectA.right - rectA.left;\n        rectA.height = rectA.bottom - rectA.top;\n        if (rectA.height !== 0 && rectA.width !== 0) {\n        // if (rectA.left < rectA.right && rectA.top < rectA.bottom) {\n            rects.push(rectA);\n        }\n    }\n\n    {\n        // inside strip\n        const rectB: IRect = {\n            bottom: rectIntersected.top,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectB.width = rectB.right - rectB.left;\n        rectB.height = rectB.bottom - rectB.top;\n        if (rectB.height !== 0 && rectB.width !== 0) {\n        // if (rectB.left < rectB.right && rectB.top < rectB.bottom) {\n            rects.push(rectB);\n        }\n    }\n\n    {\n        // inside strip\n        const rectC: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rectIntersected.bottom,\n            width: 0,\n        };\n        rectC.width = rectC.right - rectC.left;\n        rectC.height = rectC.bottom - rectC.top;\n        if (rectC.height !== 0 && rectC.width !== 0) {\n        // if (rectC.left < rectC.right && rectC.top < rectC.bottom) {\n            rects.push(rectC);\n        }\n    }\n\n    {\n        // right strip\n        const rectD: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.right,\n            right: rect1.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectD.width = rectD.right - rectD.left;\n        rectD.height = rectD.bottom - rectD.top;\n        if (rectD.height !== 0 && rectD.width !== 0) {\n        // if (rectD.left < rectD.right && rectD.top < rectD.bottom) {\n            rects.push(rectD);\n        }\n    }\n\n    return rects;\n}\n\nexport function rectSame(rect1: IRect, rect2: IRect, tolerance: number) {\n    return almostEqual(rect1.left, rect2.left, tolerance) &&\n        almostEqual(rect1.right, rect2.right, tolerance) &&\n        almostEqual(rect1.top, rect2.top, tolerance) &&\n        almostEqual(rect1.bottom, rect2.bottom, tolerance); // width and height implied correct\n}\n\nexport function rectContainsPoint(rect: IRect, x: number, y: number, tolerance: number) {\n    return (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n        (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n        (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n        (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));\n}\n\nexport function rectContains(rect1: IRect, rect2: IRect, tolerance: number) {\n    return (\n        rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) && // top left corner\n        rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) && // top right corner\n        rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) && // bottom left corner\n        rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance) // bottom right corner\n    );\n}\n\nexport function getBoundingRect(rect1: IRect, rect2: IRect): IRect {\n    const left = Math.min(rect1.left, rect2.left);\n    const right = Math.max(rect1.right, rect2.right);\n    const top = Math.min(rect1.top, rect2.top);\n    const bottom = Math.max(rect1.bottom, rect2.bottom);\n    return {\n        bottom,\n        height: bottom - top,\n        left,\n        right,\n        top,\n        width: right - left,\n    };\n}\n\nexport function rectsTouchOrOverlap(rect1: IRect, rect2: IRect, tolerance: number) {\n    return (\n        (rect1.left < rect2.right || (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n        (rect2.left < rect1.right || (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n        (rect1.top < rect2.bottom || (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n        (rect2.top < rect1.bottom || (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance)))\n    );\n}\n\nexport function mergeTouchingRects(rects: IRect[], tolerance: number, doNotMergeAlignedRects: boolean, vertical: boolean): IRect[] {\n    const LOG_PREFIX_LOCAL = \"mergeTouchingRects ~~ \";\n\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"rect1 === rect2 ??!\");\n                }\n                continue;\n            }\n\n            // horizontally-stacked lines of characters in vertical flowing text\n            // |=================||======================|\n            // |        1        ||           2          |\n            // |=================||======================|\n            const rectsLineUpVertically =\n                almostEqual(rect1.top, rect2.top, tolerance) &&\n                almostEqual(rect1.bottom, rect2.bottom, tolerance);\n            const mergeAllowedForVerticallyLinedUpRects = !doNotMergeAlignedRects || !vertical;\n\n            // vertically-stacked lines of characters in horizontal flowing text\n            // |=================|\n            // |        1        |\n            // |=================|\n            // |=================|\n            // |                 |\n            // |        2        |\n            // |                 |\n            // |=================|\n            const rectsLineUpHorizontally =\n                almostEqual(rect1.left, rect2.left, tolerance) &&\n                almostEqual(rect1.right, rect2.right, tolerance);\n            const mergeAllowedForHorizontallyLinedUpRects = !doNotMergeAlignedRects || vertical;\n\n            const doMerge =\n                // do not merge same rects (other containment operation elsewhere)\n                (\n                (rectsLineUpVertically && !rectsLineUpHorizontally)\n                ||\n                (!rectsLineUpVertically && rectsLineUpHorizontally)\n                )\n                &&\n                (\n                (rectsLineUpHorizontally && mergeAllowedForHorizontallyLinedUpRects)\n                ||\n                (rectsLineUpVertically && mergeAllowedForVerticallyLinedUpRects)\n                )\n                &&\n                rectsTouchOrOverlap(rect1, rect2, tolerance);\n\n            if (doMerge) {\n                const newRects = rects.filter((rect) => {\n                    return rect !== rect1 && rect !== rect2;\n                });\n                const boundingRect = getBoundingRect(rect1, rect2);\n                newRects.push(boundingRect);\n\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `merged ${rects.length} ==> ${newRects.length}, VERTICAL ALIGN: ${rectsLineUpVertically} HORIZONTAL ALIGN: ${rectsLineUpHorizontally} (DO NOT MERGE: ${doNotMergeAlignedRects}, VERTICAL: ${vertical}) `);\n                    logRect(rect1);\n                    console.log(\"+\");\n                    logRect(rect2);\n                    console.log(\"=\");\n                    logRect(boundingRect);\n                }\n                return mergeTouchingRects(newRects, tolerance, doNotMergeAlignedRects, vertical);\n            }\n        }\n    }\n\n    return rects;\n}\n\nexport function replaceOverlapingRects(rects: IRect[], doNotMergeAlignedRects: boolean, vertical: boolean): IRect[] {\n    const LOG_PREFIX_LOCAL = \"replaceOverlapingRects ~~ \";\n\n    if (doNotMergeAlignedRects) {\n        return rects;\n    }\n\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"rect1 === rect2 ??!\");\n                }\n                continue;\n            }\n\n            if (!rectsTouchOrOverlap(rect1, rect2, -1)) { // negative tolerance for strict overlap test\n                continue;\n            }\n\n            // horizontally-stacked lines of characters in vertical flowing text\n            // |=================||======================|\n            // |        1        ||           2          |\n            // |=================||======================|\n            // const rectsLineUpVertically =\n            //     almostEqual(possiblyContainingRect.top, rect.top, tolerance) &&\n            //     almostEqual(possiblyContainingRect.bottom, rect.bottom, tolerance);\n            // const mergeAllowedForVerticallyLinedUpRects = !doNotMergeAlignedRects || !vertical;\n\n            // vertically-stacked lines of characters in horizontal flowing text\n            // |=================|\n            // |        1        |\n            // |=================|\n            // |=================|\n            // |                 |\n            // |        2        |\n            // |                 |\n            // |=================|\n            // const rectsLineUpHorizontally =\n            //     almostEqual(possiblyContainingRect.left, rect.left, tolerance) &&\n            //     almostEqual(possiblyContainingRect.right, rect.right, tolerance);\n            // const mergeAllowedForHorizontallyLinedUpRects = !doNotMergeAlignedRects || vertical;\n\n            let toAdd: IRect[] = [];\n            let toRemove: IRect;\n            let toPreserve: IRect;\n\n            let n = 0;\n\n            // rect1 - rect2\n            const subtractRects1 = rectSubtract(rect1, rect2); // discard #1, keep #2, add returned rects\n            if (subtractRects1.length === 1) {\n                n = 1;\n                toAdd = subtractRects1;\n                toRemove = rect1;\n                toPreserve = rect2;\n            } else {\n                // rect2 - rect1\n                const subtractRects2 = rectSubtract(rect2, rect1); // discard #2, keep #1, add returned rects\n                if (subtractRects1.length < subtractRects2.length) {\n                    n = 2;\n                    toAdd = subtractRects1;\n                    toRemove = rect1;\n                    toPreserve = rect2;\n                } else {\n                    n = 3;\n                    toAdd = subtractRects2;\n                    toRemove = rect2;\n                    toPreserve = rect1;\n                }\n            }\n\n            if (IS_DEV) {\n                console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `overlap ${n} ADD: ${toAdd.length}`);\n                for (const r of toAdd) {\n                    logRect(r);\n                }\n                console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `overlap ${n} REMOVE:`);\n                logRect(toRemove);\n                console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `overlap ${n} KEEP:`);\n                logRect(toPreserve);\n            }\n\n            if (IS_DEV) {\n                const toCheck = [];\n                toCheck.push(toPreserve);\n                toCheck.push(...toAdd);\n                checkOverlaps(toCheck);\n            }\n\n            const newRects = rects.filter((rect) => {\n                return rect !== toRemove;\n            });\n            newRects.push(...toAdd);\n\n            if (IS_DEV) {\n                console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `overlap removed: ${rects.length} ==> ${newRects.length}`);\n            }\n\n            return replaceOverlapingRects(newRects, doNotMergeAlignedRects, vertical);\n        }\n    }\n\n    return rects;\n}\n\nexport function getRectOverlapX(rect1: IRect, rect2: IRect) {\n    return Math.max(0, Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left));\n}\n\nexport function getRectOverlapY(rect1: IRect, rect2: IRect) {\n    return Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top));\n}\n\nexport function removeContainedRects(rects: IRect[], tolerance: number, doNotMergeAlignedRects: boolean, vertical: boolean): IRect[] {\n    const LOG_PREFIX_LOCAL = \"removeContainedRects ~~ \";\n\n    const rectsToKeep = new Set(rects);\n\n    for (const rect of rects) {\n        const bigEnough = rect.width > 1 && rect.height > 1;\n        if (!bigEnough) {\n            if (IS_DEV) {\n                console.log(LOG_PREFIX + \"removed tiny:\");\n                logRect(rect);\n            }\n            rectsToKeep.delete(rect);\n            continue;\n        }\n        for (const possiblyContainingRect of rects) {\n            if (rect === possiblyContainingRect) {\n                continue;\n            }\n            if (!rectsToKeep.has(possiblyContainingRect) || !rectsToKeep.has(rect)) {\n                continue;\n            }\n            if (!rectContains(possiblyContainingRect, rect, tolerance)) {\n                continue;\n            }\n\n            if (doNotMergeAlignedRects) {\n\n                // horizontally-stacked lines of characters in vertical flowing text\n                // |=================||======================|\n                // |        1        ||           2          |\n                // |=================||======================|\n                const rectsLineUpVertically =\n                    almostEqual(possiblyContainingRect.top, rect.top, tolerance) &&\n                    almostEqual(possiblyContainingRect.bottom, rect.bottom, tolerance);\n                // const mergeAllowedForVerticallyLinedUpRects = !doNotMergeAlignedRects || !vertical;\n\n                // vertically-stacked lines of characters in horizontal flowing text\n                // |=================|\n                // |        1        |\n                // |=================|\n                // |=================|\n                // |                 |\n                // |        2        |\n                // |                 |\n                // |=================|\n                const rectsLineUpHorizontally =\n                    almostEqual(possiblyContainingRect.left, rect.left, tolerance) &&\n                    almostEqual(possiblyContainingRect.right, rect.right, tolerance);\n                // const mergeAllowedForHorizontallyLinedUpRects = !doNotMergeAlignedRects || vertical;\n\n                if (rectsLineUpVertically && rectsLineUpHorizontally) {\n                    // if same rects, definitely eliminate one\n                    if (IS_DEV) {\n                        console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"[identical] removed container (keep contained):\");\n                        logRect(possiblyContainingRect);\n                        logRect(rect);\n                    }\n                    rectsToKeep.delete(possiblyContainingRect);\n                    // break;\n                    continue;\n                } else if (rectsLineUpVertically || rectsLineUpHorizontally) {\n                    if (rectsLineUpVertically && !vertical || rectsLineUpHorizontally && vertical) {\n                        if (IS_DEV) {\n                            console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"[aligned] removed contained (keep container):\");\n                            logRect(rect);\n                            logRect(possiblyContainingRect);\n                        }\n                        rectsToKeep.delete(rect);\n                        // break;\n                        continue;\n                    }\n\n                    continue;\n                }\n            } else {\n                if (IS_DEV) {\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"[merge yes] removed contained (keep container):\");\n                    logRect(rect);\n                    logRect(possiblyContainingRect);\n                }\n                rectsToKeep.delete(rect);\n            }\n            // break;\n            continue;\n        }\n    }\n\n    return Array.from(rectsToKeep);\n}\n\nexport function checkOverlaps(rects: IRect[]) {\n    const LOG_PREFIX_LOCAL = \"checkOverlaps ~~ \";\n\n    const stillOverlapingRects: IRect[] = [];\n\n    for (const rect1 of rects) {\n        for (const rect2 of rects) {\n            if (rect1 === rect2) {\n                continue;\n            }\n\n            const has1 = stillOverlapingRects.includes(rect1);\n            const has2 = stillOverlapingRects.includes(rect2);\n            if (!has1 || !has2) {\n                if (rectsTouchOrOverlap(rect1, rect2, -1)) { // negative tolerance for strict overlap test\n\n                    if (!has1) {\n                        stillOverlapingRects.push(rect1);\n                    }\n                    if (!has2) {\n                        stillOverlapingRects.push(rect2);\n                    }\n\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"RECT 1:\");\n                    logRect(rect1);\n\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + \"RECT 2:\");\n                    logRect(rect2);\n\n                    const xOverlap = getRectOverlapX(rect1, rect2);\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `X overlap: ${xOverlap}`);\n\n                    const yOverlap = getRectOverlapY(rect1, rect2);\n                    console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `Y overlap: ${yOverlap}`);\n                }\n            }\n        }\n    }\n\n    if (stillOverlapingRects.length) {\n        if (IS_DEV) {\n            console.log(LOG_PREFIX + LOG_PREFIX_LOCAL + `still overlaping = ${stillOverlapingRects.length}`);\n        }\n    }\n}\n\n// https://github.com/edg2s/rangefix/blob/master/rangefix.js\n// function checkRangeFix(documant: Document) {\n\n//     const p = documant.createElement(\"p\");\n//     const span = documant.createElement(\"span\");\n//     const t1 = documant.createTextNode(\"aa\");\n//     const t2 = documant.createTextNode(\"aa\");\n//     const img = documant.createElement(\"img\");\n//     img.setAttribute(\"src\", \"#null\");\n//     p.appendChild(t1);\n//     p.appendChild(span);\n//     span.appendChild(img);\n//     span.appendChild(t2);\n//     documant.body.appendChild( p );\n\n//     const range = new Range(); // documant.createRange();\n//     range.setStart(t1, 1);\n//     range.setEnd(span, 0);\n\n//     let getBoundingClientRect = range.getClientRects().length > 1;\n//     let getClientRects = getBoundingClientRect;\n//     console.log(LOG_PREFIX + \"BUG 1: \" + getClientRects);\n\n//     if (!getClientRects) {\n//         range.setEnd(t2, 1);\n//         getBoundingClientRect = range.getClientRects().length === 2;\n//         getClientRects = getBoundingClientRect;\n//         console.log(LOG_PREFIX + \"BUG 2: \" + getClientRects);\n//     }\n\n//     if (!getBoundingClientRect) {\n//         // Safari doesn't return a valid bounding rect for collapsed ranges\n//         // Equivalent to range.collapse( true ) which isn't well supported\n//         range.setEnd(range.startContainer, range.startOffset);\n//         const boundingRect = range.getBoundingClientRect();\n//         getBoundingClientRect = boundingRect.top === 0 && boundingRect.left === 0;\n//         console.log(LOG_PREFIX + \"BUG 3: \" + getBoundingClientRect);\n//     }\n\n//     documant.body.removeChild(p);\n// }\n\n// function getClientRectsFix(range: Range): ClientRect[] | DOMRect[] {\n\n//     const rects: ClientRect[] | DOMRect[] = [];\n\n//     let endContainer: Node | null = range.endContainer;\n//     let endOffset: number = range.endOffset;\n//     let partialRange = new Range();\n\n//     while (endContainer && endContainer !== range.commonAncestorContainer) {\n//         partialRange.setStart(endContainer, 0);\n//         partialRange.setEnd(endContainer, endOffset);\n\n//         Array.prototype.push.apply(rects, partialRange.getClientRects());\n\n//         const parentNode: Node | null = endContainer.parentNode;\n//         if (parentNode) {\n//             endOffset = Array.prototype.indexOf.call(parentNode.childNodes, endContainer);\n//         }\n//         endContainer = parentNode;\n//     }\n\n//     if (endContainer) {\n//         partialRange = range.cloneRange();\n//         partialRange.setEnd(endContainer, endOffset);\n//         Array.prototype.push.apply(rects, partialRange.getClientRects());\n//     }\n\n//     return rects;\n// }\n\n// function getBoundingClientRectFix(range: Range): ClientRect | DOMRect | undefined {\n\n//     const rects = getClientRectsFix(range);\n//     if (rects.length === 0) {\n//         return undefined;\n//     }\n\n//     const nativeBoundingRect = range.getBoundingClientRect();\n//     if (nativeBoundingRect.width === 0 && nativeBoundingRect.height === 0) {\n//         return rects[0];\n//     }\n\n//     let boundingRect: ClientRect | undefined;\n\n//     for (const rect of rects) {\n//         if (!boundingRect) {\n//             boundingRect = {\n//                 bottom: rect.bottom,\n//                 height: rect.bottom - rect.top,\n//                 left: rect.left,\n//                 right: rect.right,\n//                 top: rect.top,\n//                 width: rect.right - rect.left,\n//             };\n//         } else {\n//             boundingRect.left = Math.min(boundingRect.left, rect.left);\n//             boundingRect.top = Math.min(boundingRect.top, rect.top);\n//             boundingRect.right = Math.max(boundingRect.right, rect.right);\n//             boundingRect.bottom = Math.max(boundingRect.bottom, rect.bottom);\n//             (boundingRect as any).width = boundingRect.right - boundingRect.left;\n//             (boundingRect as any).height = boundingRect.bottom - boundingRect.top;\n//         }\n//     }\n\n//     return boundingRect;\n// }\n"]}