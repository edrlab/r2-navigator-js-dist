{"version":3,"file":"rect-utils.js","sourceRoot":"","sources":["../../../../../../src/electron/renderer/common/rect-utils.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nconst VERBOSE = false;\nconst IS_DEV = VERBOSE &&\n    (process.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"dev\");\n\n// interface DOMRect extends DOMRectReadOnly {\n//     height: number;\n//     width: number;\n//     x: number;\n//     y: number;\n// }\n// interface ClientRect {\n//     bottom: number;\n//     readonly height: number;\n//     left: number;\n//     right: number;\n//     top: number;\n//     readonly width: number;\n// }\nexport interface IRectSimple {\n    height: number;\n    left: number;\n    top: number;\n    width: number;\n}\nexport interface IRect extends IRectSimple {\n    bottom: number;\n    right: number;\n}\n\nexport function getClientRectsNoOverlap(\n    range: Range,\n    doNotMergeHorizontallyAlignedRects: boolean,\n    expand?: number): IRect[] {\n\n    const rangeClientRects = range.getClientRects(); // Array.from(range.getClientRects());\n    return getClientRectsNoOverlap_(rangeClientRects, doNotMergeHorizontallyAlignedRects, expand);\n}\n\n// tslint:disable-next-line:max-line-length\nexport function getClientRectsNoOverlap_(\n    clientRects: DOMRectList, // ClientRectList\n    doNotMergeHorizontallyAlignedRects: boolean,\n    expand?: number): IRect[] {\n\n    const originalRects: IRect[] = [];\n    for (const rangeClientRect of clientRects) {\n        originalRects.push({\n            bottom: rangeClientRect.bottom,\n            height: rangeClientRect.height,\n            left: rangeClientRect.left,\n            right: rangeClientRect.right,\n            top: rangeClientRect.top,\n            width: rangeClientRect.width,\n        });\n    }\n    return getClientRectsNoOverlap__(originalRects, doNotMergeHorizontallyAlignedRects, expand);\n}\n\n// tslint:disable-next-line:max-line-length\nexport function getClientRectsNoOverlap__(\n    originalRects: IRect[],\n    doNotMergeHorizontallyAlignedRects: boolean,\n    expand?: number): IRect[] {\n\n    const ex = expand ? expand : 0;\n    if (ex) {\n        for (const rect of originalRects) {\n            rect.left -= ex;\n            rect.top -= ex;\n            rect.right += ex;\n            rect.bottom += ex;\n            rect.width += (2 * ex);\n            rect.height += (2 * ex);\n        }\n    }\n\n    const tolerance = 1;\n\n    const mergedRects = mergeTouchingRects(originalRects, tolerance, doNotMergeHorizontallyAlignedRects);\n    const noContainedRects = removeContainedRects(mergedRects, tolerance);\n    const newRects = replaceOverlapingRects(noContainedRects);\n\n    const minArea = 2 * 2;\n    for (let j = newRects.length - 1; j >= 0; j--) {\n        const rect = newRects[j];\n        let bigEnough = (rect.width * rect.height) > minArea;\n        if (bigEnough && ex && (rect.width <= ex || rect.height <= ex)) {\n            bigEnough = false;\n        }\n        if (!bigEnough) {\n            if (newRects.length > 1) {\n                if (IS_DEV) {\n                    console.log(\"CLIENT RECT: remove small\");\n                }\n                newRects.splice(j, 1);\n            } else {\n                if (IS_DEV) {\n                    console.log(\"CLIENT RECT: remove small, but keep otherwise empty!\");\n                }\n                break;\n            }\n        }\n    }\n\n    if (IS_DEV) {\n        checkOverlaps(newRects);\n    }\n\n    if (IS_DEV) {\n        console.log(`CLIENT RECT: reduced ${originalRects.length} --> ${newRects.length}`);\n    }\n    return newRects;\n}\n\n// https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/lib/rect-helpers.js\n// https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/lib/tappable-rects.js\nfunction almostEqual(a: number, b: number, tolerance: number) {\n    return Math.abs(a - b) <= tolerance;\n}\n\nexport function rectIntersect(rect1: IRect, rect2: IRect): IRect {\n    const maxLeft = Math.max(rect1.left, rect2.left);\n    const minRight = Math.min(rect1.right, rect2.right);\n    const maxTop = Math.max(rect1.top, rect2.top);\n    const minBottom = Math.min(rect1.bottom, rect2.bottom);\n    const rect: IRect = {\n        bottom: minBottom,\n        height: Math.max(0, minBottom - maxTop),\n        left: maxLeft,\n        right: minRight,\n        top: maxTop,\n        width: Math.max(0, minRight - maxLeft),\n    };\n    return rect;\n}\n\n// rect1 - rect2\nexport function rectSubtract(rect1: IRect, rect2: IRect): IRect[] {\n\n    const rectIntersected = rectIntersect(rect2, rect1);\n    if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n    // if (rectIntersected.left >= rectIntersected.right || rectIntersected.top >= rectIntersected.bottom) {\n        return [rect1];\n    }\n\n    const rects: IRect[] = [];\n\n    {\n        // left strip\n        const rectA: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rect1.left,\n            right: rectIntersected.left,\n            top: rect1.top,\n            width: 0,\n        };\n        rectA.width = rectA.right - rectA.left;\n        rectA.height = rectA.bottom - rectA.top;\n        if (rectA.height !== 0 && rectA.width !== 0) {\n        // if (rectA.left < rectA.right && rectA.top < rectA.bottom) {\n            rects.push(rectA);\n        }\n    }\n\n    {\n        // inside strip\n        const rectB: IRect = {\n            bottom: rectIntersected.top,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectB.width = rectB.right - rectB.left;\n        rectB.height = rectB.bottom - rectB.top;\n        if (rectB.height !== 0 && rectB.width !== 0) {\n        // if (rectB.left < rectB.right && rectB.top < rectB.bottom) {\n            rects.push(rectB);\n        }\n    }\n\n    {\n        // inside strip\n        const rectC: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rectIntersected.bottom,\n            width: 0,\n        };\n        rectC.width = rectC.right - rectC.left;\n        rectC.height = rectC.bottom - rectC.top;\n        if (rectC.height !== 0 && rectC.width !== 0) {\n        // if (rectC.left < rectC.right && rectC.top < rectC.bottom) {\n            rects.push(rectC);\n        }\n    }\n\n    {\n        // right strip\n        const rectD: IRect = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.right,\n            right: rect1.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectD.width = rectD.right - rectD.left;\n        rectD.height = rectD.bottom - rectD.top;\n        if (rectD.height !== 0 && rectD.width !== 0) {\n        // if (rectD.left < rectD.right && rectD.top < rectD.bottom) {\n            rects.push(rectD);\n        }\n    }\n\n    return rects;\n}\n\nexport function rectContainsPoint(rect: IRect, x: number, y: number, tolerance: number) {\n    return (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n        (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n        (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n        (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));\n}\n\nexport function rectContains(rect1: IRect, rect2: IRect, tolerance: number) {\n    return (\n        rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) && // top left corner\n        rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) && // top right corner\n        rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) && // bottom left corner\n        rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance) // bottom right corner\n    );\n}\n\nexport function getBoundingRect(rect1: IRect, rect2: IRect): IRect {\n    const left = Math.min(rect1.left, rect2.left);\n    const right = Math.max(rect1.right, rect2.right);\n    const top = Math.min(rect1.top, rect2.top);\n    const bottom = Math.max(rect1.bottom, rect2.bottom);\n    return {\n        bottom,\n        height: bottom - top,\n        left,\n        right,\n        top,\n        width: right - left,\n    };\n}\n\nexport function rectsTouchOrOverlap(rect1: IRect, rect2: IRect, tolerance: number) {\n    return (\n        (rect1.left < rect2.right || (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n        (rect2.left < rect1.right || (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n        (rect1.top < rect2.bottom || (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n        (rect2.top < rect1.bottom || (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance)))\n    );\n}\n\n// tslint:disable-next-line:max-line-length\nexport function mergeTouchingRects(rects: IRect[], tolerance: number, doNotMergeHorizontallyAlignedRects: boolean): IRect[] {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                if (IS_DEV) {\n                    console.log(\"mergeTouchingRects rect1 === rect2 ??!\");\n                }\n                continue;\n            }\n\n            const rectsLineUpVertically =\n                almostEqual(rect1.top, rect2.top, tolerance) &&\n                almostEqual(rect1.bottom, rect2.bottom, tolerance);\n\n            const rectsLineUpHorizontally =\n                almostEqual(rect1.left, rect2.left, tolerance) &&\n                almostEqual(rect1.right, rect2.right, tolerance);\n\n            const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;\n            // tslint:disable-next-line:max-line-length\n            const aligned = (rectsLineUpHorizontally && horizontalAllowed) || (rectsLineUpVertically && !rectsLineUpHorizontally);\n\n            const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);\n\n            if (canMerge) {\n                if (IS_DEV) {\n                    // tslint:disable-next-line:max-line-length\n                    console.log(`CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`);\n                }\n                const newRects = rects.filter((rect) => {\n                    return rect !== rect1 && rect !== rect2;\n                });\n                const replacementClientRect = getBoundingRect(rect1, rect2);\n                newRects.push(replacementClientRect);\n\n                return mergeTouchingRects(newRects, tolerance, doNotMergeHorizontallyAlignedRects);\n            }\n        }\n    }\n\n    return rects;\n}\n\nexport function replaceOverlapingRects(rects: IRect[]): IRect[] {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                if (IS_DEV) {\n                    console.log(\"replaceOverlapingRects rect1 === rect2 ??!\");\n                }\n                continue;\n            }\n\n            if (rectsTouchOrOverlap(rect1, rect2, -1)) { // negative tolerance for strict overlap test\n\n                let toAdd: IRect[] = [];\n                let toRemove: IRect;\n                let toPreserve: IRect;\n\n                // rect1 - rect2\n                const subtractRects1 = rectSubtract(rect1, rect2); // discard #1, keep #2, add returned rects\n                if (subtractRects1.length === 1) {\n                    toAdd = subtractRects1;\n                    toRemove = rect1;\n                    toPreserve = rect2;\n                } else {\n                    // rect2 - rect1\n                    const subtractRects2 = rectSubtract(rect2, rect1); // discard #2, keep #1, add returned rects\n                    if (subtractRects1.length < subtractRects2.length) {\n                        toAdd = subtractRects1;\n                        toRemove = rect1;\n                        toPreserve = rect2;\n                    } else {\n                        toAdd = subtractRects2;\n                        toRemove = rect2;\n                        toPreserve = rect1;\n                    }\n                }\n\n                if (IS_DEV) {\n                    const toCheck = [];\n                    toCheck.push(toPreserve);\n                    Array.prototype.push.apply(toCheck, toAdd);\n                    checkOverlaps(toCheck);\n                }\n\n                if (IS_DEV) {\n                    console.log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);\n                }\n                const newRects = rects.filter((rect) => {\n                    return rect !== toRemove;\n                });\n                Array.prototype.push.apply(newRects, toAdd);\n\n                return replaceOverlapingRects(newRects);\n            }\n        }\n    }\n\n    return rects;\n}\n\nexport function getRectOverlapX(rect1: IRect, rect2: IRect) {\n    return Math.max(0, Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left));\n}\n\nexport function getRectOverlapY(rect1: IRect, rect2: IRect) {\n    return Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top));\n}\n\nexport function removeContainedRects(rects: IRect[], tolerance: number): IRect[] {\n\n    const rectsToKeep = new Set(rects);\n\n    for (const rect of rects) {\n        const bigEnough = rect.width > 1 && rect.height > 1;\n        if (!bigEnough) {\n            if (IS_DEV) {\n                console.log(\"CLIENT RECT: remove tiny\");\n            }\n            rectsToKeep.delete(rect);\n            continue;\n        }\n        for (const possiblyContainingRect of rects) {\n            if (rect === possiblyContainingRect) {\n                continue;\n            }\n            if (!rectsToKeep.has(possiblyContainingRect)) {\n                continue;\n            }\n            if (rectContains(possiblyContainingRect, rect, tolerance)) {\n                if (IS_DEV) {\n                    console.log(\"CLIENT RECT: remove contained\");\n                }\n                rectsToKeep.delete(rect);\n                break;\n            }\n        }\n    }\n\n    return Array.from(rectsToKeep);\n}\n\nexport function checkOverlaps(rects: IRect[]) {\n\n    const stillOverlapingRects: IRect[] = [];\n\n    for (const rect1 of rects) {\n        for (const rect2 of rects) {\n            if (rect1 === rect2) {\n                continue;\n            }\n            const has1 = stillOverlapingRects.indexOf(rect1) >= 0;\n            const has2 = stillOverlapingRects.indexOf(rect2) >= 0;\n            if (!has1 || !has2) {\n                if (rectsTouchOrOverlap(rect1, rect2, -1)) { // negative tolerance for strict overlap test\n\n                    if (!has1) {\n                        stillOverlapingRects.push(rect1);\n                    }\n                    if (!has2) {\n                        stillOverlapingRects.push(rect2);\n                    }\n\n                    console.log(\"CLIENT RECT: overlap ---\");\n                    // tslint:disable-next-line:max-line-length\n                    console.log(`#1 TOP:${rect1.top} BOTTOM:${rect1.bottom} LEFT:${rect1.left} RIGHT:${rect1.right} WIDTH:${rect1.width} HEIGHT:${rect1.height}`);\n                    // tslint:disable-next-line:max-line-length\n                    console.log(`#2 TOP:${rect2.top} BOTTOM:${rect2.bottom} LEFT:${rect2.left} RIGHT:${rect2.right} WIDTH:${rect2.width} HEIGHT:${rect2.height}`);\n\n                    const xOverlap = getRectOverlapX(rect1, rect2);\n                    console.log(`xOverlap: ${xOverlap}`);\n\n                    const yOverlap = getRectOverlapY(rect1, rect2);\n                    console.log(`yOverlap: ${yOverlap}`);\n                }\n            }\n        }\n    }\n    if (stillOverlapingRects.length) {\n        console.log(`CLIENT RECT: overlaps ${stillOverlapingRects.length}`);\n        // for (const rect of stillOverlapingRects) {\n        // tslint:disable-next-line:max-line-length\n        //     console.log(`CLIENT RECT: remaining overlaps TOP:${rect.top} BOTTOM:${rect.bottom} LEFT:${rect.left} RIGHT:${rect.right} WIDTH:${rect.width} HEIGHT:${rect.height}`);\n        // }\n    }\n}\n\n// https://github.com/edg2s/rangefix/blob/master/rangefix.js\n// function checkRangeFix(documant: Document) {\n\n//     const p = documant.createElement(\"p\");\n//     const span = documant.createElement(\"span\");\n//     const t1 = documant.createTextNode(\"aa\");\n//     const t2 = documant.createTextNode(\"aa\");\n//     const img = documant.createElement(\"img\");\n//     img.setAttribute(\"src\", \"#null\");\n//     p.appendChild(t1);\n//     p.appendChild(span);\n//     span.appendChild(img);\n//     span.appendChild(t2);\n//     documant.body.appendChild( p );\n\n//     const range = new Range(); // documant.createRange();\n//     range.setStart(t1, 1);\n//     range.setEnd(span, 0);\n\n//     let getBoundingClientRect = range.getClientRects().length > 1;\n//     let getClientRects = getBoundingClientRect;\n//     console.log(\"BUG 1: \" + getClientRects);\n\n//     if (!getClientRects) {\n//         range.setEnd(t2, 1);\n//         getBoundingClientRect = range.getClientRects().length === 2;\n//         getClientRects = getBoundingClientRect;\n//         console.log(\"BUG 2: \" + getClientRects);\n//     }\n\n//     if (!getBoundingClientRect) {\n//         // Safari doesn't return a valid bounding rect for collapsed ranges\n//         // Equivalent to range.collapse( true ) which isn't well supported\n//         range.setEnd(range.startContainer, range.startOffset);\n//         const boundingRect = range.getBoundingClientRect();\n//         getBoundingClientRect = boundingRect.top === 0 && boundingRect.left === 0;\n//         console.log(\"BUG 3: \" + getBoundingClientRect);\n//     }\n\n//     documant.body.removeChild(p);\n// }\n\n// function getClientRectsFix(range: Range): ClientRect[] | DOMRect[] {\n\n//     const rects: ClientRect[] | DOMRect[] = [];\n\n//     let endContainer: Node | null = range.endContainer;\n//     let endOffset: number = range.endOffset;\n//     let partialRange = new Range();\n\n//     while (endContainer && endContainer !== range.commonAncestorContainer) {\n//         partialRange.setStart(endContainer, 0);\n//         partialRange.setEnd(endContainer, endOffset);\n\n//         Array.prototype.push.apply(rects, partialRange.getClientRects());\n\n//         const parentNode: Node | null = endContainer.parentNode;\n//         if (parentNode) {\n//             endOffset = Array.prototype.indexOf.call(parentNode.childNodes, endContainer);\n//         }\n//         endContainer = parentNode;\n//     }\n\n//     if (endContainer) {\n//         partialRange = range.cloneRange();\n//         partialRange.setEnd(endContainer, endOffset);\n//         Array.prototype.push.apply(rects, partialRange.getClientRects());\n//     }\n\n//     return rects;\n// }\n\n// function getBoundingClientRectFix(range: Range): ClientRect | DOMRect | undefined {\n\n//     const rects = getClientRectsFix(range);\n//     if (rects.length === 0) {\n//         return undefined;\n//     }\n\n//     const nativeBoundingRect = range.getBoundingClientRect();\n//     if (nativeBoundingRect.width === 0 && nativeBoundingRect.height === 0) {\n//         return rects[0];\n//     }\n\n//     let boundingRect: ClientRect | undefined;\n\n//     for (const rect of rects) {\n//         if (!boundingRect) {\n//             boundingRect = {\n//                 bottom: rect.bottom,\n//                 height: rect.bottom - rect.top,\n//                 left: rect.left,\n//                 right: rect.right,\n//                 top: rect.top,\n//                 width: rect.right - rect.left,\n//             };\n//         } else {\n//             boundingRect.left = Math.min(boundingRect.left, rect.left);\n//             boundingRect.top = Math.min(boundingRect.top, rect.top);\n//             boundingRect.right = Math.max(boundingRect.right, rect.right);\n//             boundingRect.bottom = Math.max(boundingRect.bottom, rect.bottom);\n//             (boundingRect as any).width = boundingRect.right - boundingRect.left;\n//             (boundingRect as any).height = boundingRect.bottom - boundingRect.top;\n//         }\n//     }\n\n//     return boundingRect;\n// }\n"]}